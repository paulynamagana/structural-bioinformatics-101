[
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Why Python for Structural Biologists?\nWelcome to the world of programming with Python, specifically tailored for structural biologists and researchers in related fields! In an era where biological datasets are growing exponentially in size and complexity—from high-resolution atomic coordinates in PDB files and vast ‘omics’ studies to dynamic molecular simulations—computational skills are no longer a niche expertise but a fundamental tool for research and discovery.\nThis document aims to provide you with a solid foundation in Python programming and using Google Colaboratory, empowering you to analyze structural and sequence data effectively, automate repetitive tasks, and ultimately, harness the power of computation in your scientific endeavors.\nPython has become a dominant programming language in the scientific community, especially in biology and increasingly in structural bioinformatics, for several compelling reasons:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#why-python-for-structural-biologists",
    "href": "introduction.html#why-python-for-structural-biologists",
    "title": "1  Introduction",
    "section": "",
    "text": "Readability and Simplicity: Python’s syntax is designed to be clear and intuitive, resembling plain English. This significantly lowers the barrier to entry, making it relatively easy to learn, write, and understand, even if you have no prior programming experience. This means less time wrestling with complex syntax and more time focusing on biological questions. For example, imagine trying to write a script to calculate the distance between two atoms in a PDB file. Python’s clear syntax makes this more intuitive than in lower-level languages.\nExtensive Libraries: Python boasts a rich ecosystem of specialized libraries (collections of pre-written code) for bioinformatics, data analysis, machine learning, and visualization. For structural biologists, key libraries include BioPython (for PDB parsing, sequence analysis), NumPy (for numerical operations on coordinates or simulation data), MDAnalysis or PyTraj (for analyzing molecular dynamics trajectories), and tools to script visualizers like PyMOL or NGLView. These provide pre-built tools that handle complex tasks, saving you significant development time. Instead of writing code from scratch to parse a PDB file, you can use a BioPython function.\nVersatile Data Handling: From parsing diverse sequence file formats (FASTA, GenBank), analyzing genomic sequences, and manipulating protein structures (PDB, mmCIF), to managing large tabular datasets from simulation outputs or ligand screening, Python excels at handling the varied and often complex data types encountered in structural biology. Python excels at parsing complex PDB or mmCIF files, extracting specific chain information, analyzing lists of ligand interactions, or processing output from docking simulations.\nAutomation of Repetitive Tasks: Many structural analyses involve repetitive steps: downloading hundreds of PDB files, running the same structural alignment algorithm on multiple protein pairs, extracting B-factors for all C-alpha atoms in a set of structures, or batch-processing molecular dynamics simulation outputs. Python scripts can automate these tasks flawlessly and efficiently, freeing up your valuable time for data interpretation, experimental design, and scientific discovery.\nReproducibility: A cornerstone of good scientific practice is reproducibility. Writing scripts for your analysis ensures that your methods are clearly documented and can be exactly reproduced by yourself (months or years later) or by others in the scientific community. Ensuring that your analysis of a protein’s conformational changes, or the method you used to identify conserved residues across a protein family, is perfectly reproducible is critical. Python scripts serve as an executable record of your workflow.\nInterdisciplinary Collaboration: Python is widely used across many scientific and technical fields. This common language facilitates collaboration with computational chemists running simulations, crystallographers generating structure data, biochemists, or data scientists, allowing for more integrated and powerful research approaches.\nVibrant Community Support: A vast and active global community of Python users means abundant tutorials, well-documented libraries, active forums (like Stack Overflow, BioStars), and readily available help when you encounter challenges or need to learn a new technique. You’re rarely the first person to encounter a specific problem.\nIntegration Capabilities: Python can easily integrate with other software tools, databases (SQL, NoSQL), web services (e.g., APIs for RCSB PDB, UniProt, ENSEMBL), and even command-line programs often used in structural biology (like GROMACS, NAMD, or alignment tools). This makes it a flexible hub for building complex analytical pipelines.\nVisualization Power: While Python itself isn’t a visualizer, libraries like Matplotlib and Seaborn allow you to create a wide array of publication-quality plots and figures—from simple bar charts and scatter plots of structural parameters (like Ramachandran plots or RMSD over time) to complex heatmaps of contact frequencies. Moreover, Python can script powerful molecular visualization tools like PyMOL or NGLView to highlight active sites, map conservation scores onto structures, or generate publication-quality images and movies of macromolecules.\n\n\n1.1.1 Python in the Structural Bioinformatics Pipeline\nPython can be instrumental at various stages of a typical structural bioinformatics workflow:\n\nData Retrieval: Automating the download of PDB files from the RCSB PDB, fetching sequences from UniProt or NCBI, or querying other biological databases via their APIs.\nSequence Analysis: Analyzing protein sequences (e.g., from FASTA files), identifying motifs, comparing sequences of structural homologs, performing multiple sequence alignments (often by interfacing with external tools).\nStructure Parsing and Preprocessing: Reading and parsing atomic coordinate files (PDB, mmCIF) using libraries like BioPython to extract information about atoms, residues, chains, ligands, and experimental details. Cleaning structures, renumbering residues, or selecting specific parts of a structure.\nStructure Analysis:\n\nCalculating geometric properties: distances, angles, dihedral angles (e.g., Ramachandran plots).\nIdentifying interactions: hydrogen bonds, salt bridges, hydrophobic contacts, ligand interactions.\nComparing structures: calculating RMSD, performing structural alignments. Analyzing B-factors, solvent accessibility (SASA), and other per-residue or per-atom properties.\n\nMolecular Simulation Analysis: Reading and processing trajectory files from molecular dynamics (MD) simulations (e.g., using MDAnalysis or PyTraj). Calculating RMSD, RMSF, radius of gyration, analyzing principal components of motion, and identifying conformational changes.\nData Integration: Combining structural data with other data types, such as sequence conservation scores, experimental binding affinities, or genomic information. Visualization Scripting: Automating tasks in molecular graphics programs like PyMOL or NGLView to generate consistent visualizations, highlight specific features, or create animations.\nDeveloping Custom Tools: Building custom scripts and small tools for specific analytical tasks not readily available in existing software. Machine Learning Applications: Preparing structural data for input into machine learning models or analyzing outputs from structure prediction tools (like AlphaFold).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#introduction-to-google-colaboratory-colab",
    "href": "introduction.html#introduction-to-google-colaboratory-colab",
    "title": "1  Introduction",
    "section": "1.2 Introduction to Google Colaboratory (Colab)",
    "text": "1.2 Introduction to Google Colaboratory (Colab)\nGoogle Colaboratory (Colab) is a free, cloud-based Jupyter notebook environment that allows you to write and execute Python code directly in your web browser. It’s an excellent platform for learning and for many research tasks, especially for structural biologists, due to its accessibility and features:\n\nNo Installation Hassle: Colab requires no setup on your part. All you need is a Google account and an internet connection. This is particularly beneficial for workshops or when working across different computers.\nFree Access to Computing Resources: Colab provides free access to computational resources, including Graphics Processing Units (GPUs). While many basic structural analyses won’t need them, if you later delve into AI-driven structure prediction (like AlphaFold, which can be run or analyzed in Colab environments) or complex molecular dynamics simulations, Colab’s free access to GPUs can be invaluable. Interactive Notebooks: Colab uses Jupyter notebooks, allowing you to create documents containing live code, equations (LaTeX), visualizations, images, and narrative text. Imagine loading a PDB file, calculating the center of mass of a protein, then immediately visualizing a specific region with its B-factors plotted – all within one interactive Colab notebook.\nEasy Collaboration and Sharing: Colab notebooks can be easily shared, much like Google Docs.\nIntegration with Google Drive: Notebooks and data files can be saved and accessed from your Google Drive.\nPre-installed Libraries: Many common data science libraries are pre-installed. Key bioinformatics libraries like BioPython are often available or easily installable within a notebook cell using !pip install biopython.\n\nGetting Started with Colab\n\nAccess Colab: Navigate to https://colab.research.google.com/.\nSign In: Use your Google account.\nCreate a New Notebook: Select “New notebook” from the pop-up or File menu.\n\nUnderstanding the Colab Interface\n\nCells:\n\nCode cells: Write and execute Python code (Shift + Enter to run). Output appears below.\nText cells: Write text, headings, notes using Markdown (Shift + Enter to render).\n\nMenu Bar & toolbar: For file operations, editing, cell insertion, runtime management.\nRuntime: The cloud engine running your code. Manage via “Runtime” menu (e.g., restart, change to GPU).\nLeft sidebar: Table of Contents, Code Snippets, File Browser (upload files or mount Google Drive).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#setting-up-your-environment",
    "href": "introduction.html#setting-up-your-environment",
    "title": "1  Introduction",
    "section": "1.3 Setting Up Your Environment",
    "text": "1.3 Setting Up Your Environment\n\nGoogle Colab (Recommended for Beginners): Zero-setup, ideal for learning.\nLocal Python Installation (Optional, for advanced use):\n\nAnaconda Distribution (Highly Recommended for Scientists): Simplifies package management. Comes with Python, conda (package manager), and many scientific libraries. Anaconda makes it easier to manage specific versions of libraries like BioPython, NumPy, and potentially PyMOL (though PyMOL’s own installation is often separate or via specific conda channels like psi4 or conda-forge). Download from anaconda.com.\nCode Editor/IDE: VS Code, Spyder (comes with Anaconda), PyCharm. Jupyter Notebook/Lab offer a Colab-like local interface.\n\n\nFor this tutorial, all examples are designed to be run directly in Google Colab.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "python-fundamentals.html",
    "href": "python-fundamentals.html",
    "title": "2  Python Fundamentals",
    "section": "",
    "text": "2.1 Variables and Data Types\nLet’s dive into the basic building blocks of Python. Think of these as the fundamental vocabulary and grammar you’ll use to tell the computer what to do. Mastering these basics will empower you to process and understand biological data.\nIn programming, a variable is like a named container or a labeled box in your computer’s memory where you can store data. When you want to use that data later, you just refer to the variable’s name.\nPython is a dynamically typed language. This means you don’t need to explicitly tell Python what type of data a variable will hold (e.g., integer, text, decimal number) when you create it. Python automatically infers the type based on the value you assign. This makes Python very flexible and quicker to write for beginners, but it also means you need to be mindful of the data types you’re working with during operations.\nVariable Naming Rules (PEP 8 Style): To make your code readable and consistent (especially important when working with others or revisiting your own code later), follow these common conventions:\nCommon Data Types in Python for Structural Biology\nPython comes with several built-in data types that are fundamental for storing and manipulating information. Here are the most common ones you’ll encounter, with a focus on their applications in structural bioinformatics:\nnumber_of_amino_acids = 287\natom_serial_number = 1560\n\nprint(f\"Number of amino acids: {number_of_amino_acids}\")\nprint(f\"Atom serial number: {atom_serial_number}\")\n\n# The type() function tells you what data type a variable holds\nprint(f\"Type of atom_serial_number: {type(atom_serial_number)}\") # Output: &lt;class 'int'&gt;\n\nNumber of amino acids: 287\nAtom serial number: 1560\nType of atom_serial_number: &lt;class 'int'&gt;\nExercise: Define a variable total_atoms_in_myoglobin and assign it an approximate number of atoms (e.g., 1260). Print the variable and its type.\nWhat they are: Numbers that have a decimal point or are expressed in scientific notation. They are used to represent real numbers, often for measurements that are not whole numbers.\n# Atomic coordinates for a C-alpha atom\nca_x_coord = 10.253\nca_y_coord = -5.781\nca_z_coord = 22.019\nprint(f\"C-alpha coordinates: X={ca_x_coord}, Y={ca_y_coord}, Z={ca_z_coord}\")\n\nC-alpha coordinates: X=10.253, Y=-5.781, Z=22.019\nrmsd_to_native = 0.85 # Angstroms (Å is the symbol for Angstrom)\nprint(f\"RMSD to native structure: {rmsd_to_native} Å\")\nprint(f\"Type of rmsd_to_native: {type(rmsd_to_native)}\") # Output: &lt;class 'float'&gt;\n\nRMSD to native structure: 0.85 Å\nType of rmsd_to_native: &lt;class 'float'&gt;\nExercise: Define three float variables: coord_x = 10.123, coord_y = -4.567, coord_z = 18.901. Print these coordinates in a formatted string, perhaps like “Coordinates: (X: 10.123, Y: -4.567, Z: 18.901)”.\nWhat they are: Sequences of characters (text). Strings are immutable, meaning once created, their individual characters cannot be changed. Any operation that seems to modify a string actually creates a new string.\nHow to define strings:\nUse Cases in Structural Bioinformatics:\nprotein_data_bank_id = \"2HHB\" # Hemoglobin\namino_acid_sequence_snippet = \"VLSPADKTNVKAAWGKVGAHAGEYGAEALE\"\n\n# A multi-line string for a simplified PDB ATOM record example\natom_record_line_pdb = \"\"\"\nATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\nATOM      2  CA  MET A   1      25.500  23.800  23.100  1.00 12.00           C\n\"\"\"\nprint(f\"Analyzing PDB ID: {protein_data_bank_id}\")\nprint(f\"Amino acid sequence snippet: {amino_acid_sequence_snippet}\")\nprint(f\"Example PDB ATOM line (multi-line): {atom_record_line_pdb}\")\nprint(f\"Type of protein_data_bank_id: {type(protein_data_bank_id)}\") # Output: &lt;class 'str'&gt;\n\nAnalyzing PDB ID: 2HHB\nAmino acid sequence snippet: VLSPADKTNVKAAWGKVGAHAGEYGAEALE\nExample PDB ATOM line (multi-line): \nATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\nATOM      2  CA  MET A   1      25.500  23.800  23.100  1.00 12.00           C\n\nType of protein_data_bank_id: &lt;class 'str'&gt;\nExercise: Create a string variable target_pdb_code and assign it \"1CBS\". Create another string variable ligand_name and assign it \"STI\" (a substrate analog for 1CBS). Print both variables in a sentence, e.g., “The target PDB is [code], and its ligand is [name].”\nWhat they are: Truth values. A boolean variable can only hold one of two possible values: True or False. These are special keywords in Python (notice the capital first letter). Booleans are the foundation of decision-making in your code.\nUse Cases in Structural Bioinformatics:\nis_structure_solved_by_xray = True\nhas_hydrogen_atoms_in_pdb = False # Often true for NMR, sometimes for high-res X-ray, but usually False for older X-ray PDBs\nis_distance_significant = (2.8 &lt; 3.5) # This is a comparison, which directly evaluates to True or False\nprint(f\"Structure solved by X-ray? {is_structure_solved_by_xray}\")\nprint(f\"Hydrogen atoms present? {has_hydrogen_atoms_in_pdb}\")\nprint(f\"Is the distance significant for an H-bond (2.8 &lt; 3.5)? {is_distance_significant}\")\nprint(f\"Type of is_distance_significant: {type(is_distance_significant)}\") # Output: &lt;class 'bool'&gt;\n\nStructure solved by X-ray? True\nHydrogen atoms present? False\nIs the distance significant for an H-bond (2.8 &lt; 3.5)? True\nType of is_distance_significant: &lt;class 'bool'&gt;\nExercise: Imagine you’ve calculated the B-factor of an atom as b_factor_value = 55.2. Create a boolean variable is_atom_flexible that is True if b_factor_value is greater than 50.0, and False otherwise. Print the value of is_atom_flexible.\nSometimes, you need to convert data from one type to another. This process is called “type conversion” or “casting.” Python provides built-in functions for this: int(), float(), str(), bool().\nContext in Structural Bioinformatics: A common scenario is when you read data from a file (like a PDB file). Although numbers (coordinates, B-factors, occupancy) are stored as text (strings) in the file, you’ll need to convert them to float or int to perform numerical calculations.\ncoordinate_str = \"12.345\" # This value is read as a string from a PDB file line\ncoordinate_float = float(coordinate_str) # Convert the string to a floating-point number\nprint(f\"Coordinate string '{coordinate_str}' as float: {coordinate_float}\")\nprint(f\"Type of coordinate_float: {type(coordinate_float)}\") # Output: &lt;class 'float'&gt;\n\nCoordinate string '12.345' as float: 12.345\nType of coordinate_float: &lt;class 'float'&gt;\natom_count_str = \"5000\"\natom_count_int = int(atom_count_str) # Convert the string to an integer\nprint(f\"Atom count '{atom_count_str}' as int: {atom_count_int}\")\nprint(atom_count_int * 2) # Now arithmetic operations are possible: 10000\n\nAtom count '5000' as int: 5000\n10000\n# Careful with float to int conversion: it truncates (chops off the decimal part), it does NOT round.\noccupancy_str = \"0.75\"\noccupancy_float = float(occupancy_str)\noccupancy_int_truncated = int(occupancy_float) # Becomes 0 (truncates 0.75 to 0)\nprint(f\"Occupancy '{occupancy_str}' as float: {occupancy_float}, as int (truncated): {occupancy_int_truncated}\")\n\nOccupancy '0.75' as float: 0.75, as int (truncated): 0\n# Converting to boolean:\n# Most non-empty strings, non-zero numbers, non-empty lists/tuples/dictionaries evaluate to True\n# Empty strings, 0, None, empty lists/tuples/dictionaries evaluate to False\nis_present_str = \"True\"\nis_present_bool = bool(is_present_str) # This will be True because the string \"True\" is not empty\nprint(f\"'{is_present_str}' as boolean: {is_present_bool}\")\n\nempty_sequence_str = \"\"\nis_empty_bool = bool(empty_sequence_str) # This will be False\nprint(f\"'{empty_sequence_str}' as boolean: {is_empty_bool}\")\n\n'True' as boolean: True\n'' as boolean: False",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Fundamentals</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Structural Bioinformatics 101",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "python-fundamentals.html#variables-and-data-types",
    "href": "python-fundamentals.html#variables-and-data-types",
    "title": "2  Python Fundamentals",
    "section": "",
    "text": "Lowercase with underscores (snake_case): This is the standard for variable and function names. Examples: pdb_id, atom_count, active_site_residues.\nStart with a letter or underscore: Variable names cannot begin with a number.\n\nValid: _temp_value, residue_10, chain_A.\nInvalid: 10_residues, 2nd_atom\n\nCase-sensitive: Python distinguishes between uppercase and lowercase letters. atom_name is a completely different variable from Atom_Name.\nAvoid Python keywords: Do not use words that Python reserves for its own syntax (e.g., if, for, list, def, return, True, False, None). Using them will cause a SyntaxError.\nBe descriptive: Choose names that clearly indicate the purpose or content of the variable. This makes your code much easier to understand.Good: active_site_residues, rmsd_value_angstroms, protein_sequenceBad: asr, x, p_seq\n\n\n\n\nIntegers (int): What they are: Whole numbers (positive, negative, or zero) without any fractional part.\nUse Cases in Structural Bioinformatics:\n\nCounting discrete entities: number_of_atoms = 4582, chain_count = 2.\nIdentifiers: residue_number = 101, atom_serial_number = 1560.\nSimulation steps: simulation_step = 50000.\n\n\n\n\n\nFloating-Point Numbers (float):\n\n\n\nUse Cases in Structural Bioinformatics:\nAtomic coordinates: x_coord = 12.345, y_coord = -4.567, z_coord = 18.901.\nMeasurements: RMSD values (rmsd_value = 1.5), B-factors (b_factor = 45.67), bond lengths (bond_length_angstroms = 1.54), solvent accessible surface area (SASA), resolution of crystal structures.\n\n\n\n\n\nStrings (str):\n\n\n\n\nSingle quotes (‘…’) or Double quotes (“…”): Use these for single-line strings. It’s largely a matter of personal preference or team convention, but choose one and stick to it for consistency.\n\nIf your string contains an apostrophe, use double quotes to avoid issues (e.g., “It’s a protein”).\nIf your string contains double quotes, use single quotes (e.g., ‘The “alpha” carbon’).\n\nTriple quotes (“““…”“” or ’’‘…’’’): Use triple single or double quotes for multi-line strings. This is extremely useful for storing blocks of text, such as descriptions, help messages, or raw data snippets that span multiple lines, like a portion of a PDB file header or a long protein sequence.\n\n\n\nPDB IDs: pdb_id = '1AKE', protein_data_bank_id = \"2HHB\".\nAtom names: atom_name = 'CA', element_symbol = \"C\".\nResidue names: residue_name = 'ALA', three_letter_code = \"GLY\".\nChain identifiers: chain_id = 'A'.\nBiological sequences: protein_sequence = \"MVLSEGEWQLVLHVWAKVEAD\", dna_sequence = \"ATGCGTAGCATG\".\nFile paths: pdb_file_path = \"data/1crn.pdb\".\nLines from data files: atom_record_line_pdb = \"ATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\".\n\n\n\n\nBooleans (bool):\n\n\n\n\nFlags for presence/absence: is_ligand_present = True, has_hydrogen_atoms_in_pdb = False.\nResults of comparisons: resolution_ok = (pdb_resolution &lt; 2.0), is_distance_significant = (2.8 &lt; 3.5).\nCategorization: is_alpha_helix = True, is_clash_detected = False.\n\n\n\n\nType Conversion (Casting):",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Fundamentals</span>"
    ]
  },
  {
    "objectID": "python-fundamentals.html#operators-the-tools-for-data-manipulation",
    "href": "python-fundamentals.html#operators-the-tools-for-data-manipulation",
    "title": "2  Python Fundamentals",
    "section": "2.2 Operators: The Tools for Data Manipulation",
    "text": "2.2 Operators: The Tools for Data Manipulation\nOperators are special symbols or keywords that perform operations on variables and values (called operands). Understanding operators is crucial for performing calculations, making comparisons, and combining conditions in your code.\nArithmetic Operators:\nUsed to perform mathematical calculations.\nOperators: * + (Addition) * - (Subtraction) * * (Multiplication) * / (True Division): Performs standard division, always returning a float (even if the result is a whole number).\n\n// (Floor Division): Performs division and returns the integer part of the quotient (rounds down to the nearest whole number).\n% (Modulo): Returns the remainder of a division.\n** (Exponentiation): Raises the first operand to the power of the second.\n\nUse Cases in Structural Bioinformatics:\n\nCalculating distances between atoms (e.g., Euclidean distance:\nAveraging B-factors or other numerical properties.\nScaling coordinates.\nCalculating molecular weights (summing up atomic weights).\n\n\n# Simplified distance calculation in 1D for now\natom1_x = 10.0\natom2_x = 15.5\ndelta_x = atom2_x - atom1_x # Difference in X-coordinate: 5.5\ndistance_sq_x = delta_x ** 2 # Square of the difference: 5.5 * 5.5 = 30.25\nprint(f\"Difference in X: {delta_x}, Squared difference: {distance_sq_x}\")\n\n# Average B-factor of two atoms\nb_factor1 = 20.5\nb_factor2 = 30.1\naverage_b_factor = (b_factor1 + b_factor2) / 2 # Division results in float: 25.3\nprint(f\"Average B-factor: {average_b_factor}\")\n\nsequence_length = 101 # Example: number of residues\nresidues_per_turn_helix = 3.6 # Approximate number of residues per turn in an alpha-helix\napprox_turns = sequence_length / residues_per_turn_helix # True division: 101 / 3.6 = 28.055...\nfull_turns = sequence_length // residues_per_turn_helix # Floor division: 101 // 3.6 = 28.0 (type is float but value is integer part)\n# Note: If both operands are integers, // returns an integer. If either is float, it returns a float.\nprint(f\"Approximate turns in helix: {approx_turns:.2f}, Full turns: {full_turns}\")\n\nremainder_check = 10 % 3 # Modulo: 10 divided by 3 is 3 with a remainder of 1\nprint(f\"Remainder of 10 / 3: {remainder_check}\") # Output: 1\n\nDifference in X: 5.5, Squared difference: 30.25\nAverage B-factor: 25.3\nApproximate turns in helix: 28.06, Full turns: 28.0\nRemainder of 10 / 3: 1\n\n\nExercise: Given x1 = 5.0, y1 = 10.0 and x2 = 8.0, y2 = 14.0. Calculate the squared distance in 2D: \\[(x2−x1)^2+(y2−y1)^2\\] Store the result in a variable sq_dist_2d and print it.\nComparison Operators:\nWhat they are: Used to compare two values. They always return a Boolean value (True or False).\nOperators:\n\n== (Equal to): Returns True if two operands have the same value.\n!= (Not equal to): Returns True if two operands have different values.\n&gt; (Greater than)\n&lt; (Less than)\n&gt;= (Greater than or equal to)\n&lt;= (Less than or equal to)\n\nUse Cases in Structural Bioinformatics:\n\nComparing resolution values: resolution1 &lt; resolution2.\nChecking if a B-factor exceeds a threshold: b_factor &gt; 70.0.\nComparing atom names: atom_name == 'CA'.\nChecking if a residue number is within a specific range: residue_number &gt;= 10 and residue_number &lt;= 20.\n\n\nmy_protein_resolution = 1.8 # Angstroms\nacceptable_resolution_max = 2.5\nis_good_resolution = my_protein_resolution &lt;= acceptable_resolution_max # 1.8 is less than or equal to 2.5, so True\nprint(f\"Is resolution {my_protein_resolution}Å acceptable (&lt;= {acceptable_resolution_max}Å)? {is_good_resolution}\")\n\natom_type = \"C\"\nis_carbon_atom = atom_type == \"C\" # Is \"C\" equal to \"C\"? True\nprint(f\"Is atom_type '{atom_type}' a Carbon? {is_carbon_atom}\")\n\n# Check if a chain ID is not 'X' (often used for unknown chains)\nchain_id = \"A\"\nis_not_unknown_chain = chain_id != \"X\" # \"A\" is not equal to \"X\", so True\nprint(f\"Is chain '{chain_id}' not an unknown chain? {is_not_unknown_chain}\")\n\nIs resolution 1.8Å acceptable (&lt;= 2.5Å)? True\nIs atom_type 'C' a Carbon? True\nIs chain 'A' not an unknown chain? True\n\n\nExercise: A typical hydrogen bond length is between 2.7 and 3.3 Angstroms. Given measured_hbond_length = 2.9, write a comparison to check if it’s less than or equal to 3.3. Print the result.\nLogical Operators What they are: Used to combine multiple Boolean expressions. They also return a Boolean value (True or False).\nOperators:\n\nand: Returns True if both operands are True.\nor: Returns True if at least one of the operands is True.\nnot: Reverses the logical state of its operand (if True becomes False, if False becomes True).\n\nUse Cases in Structural Bioinformatics:\n\nChecking if a residue is part of an alpha-helix AND is solvent exposed: is_helix and is_exposed.\nChecking if an atom is a backbone atom (C-alpha OR N OR C OR O): (atom_name == 'CA') or (atom_name == 'N') or (atom_name == 'C') or (atom_name == 'O').\nChecking if a structure is not an NMR structure: not (experimental_method == 'NMR').\n\n\nis_hydrophobic_residue = True\nis_surface_exposed = False\n# Is it a surface-exposed hydrophobic residue? Both conditions must be True.\nis_hydrophobic_and_surface = is_hydrophobic_residue and is_surface_exposed # True and False -&gt; False\nprint(f\"Is the residue hydrophobic AND surface exposed? {is_hydrophobic_and_surface}\")\n\natom_name_check = \"CB\" # C-beta\n# Is it a main chain atom? (N, CA, C, or O)\nis_main_chain_atom = (atom_name_check == \"N\" or atom_name_check == \"CA\" or atom_name_check == \"C\" or atom_name_check == \"O\")\n# \"CB\" == \"N\" (False) OR \"CB\" == \"CA\" (False) OR \"CB\" == \"C\" (False) OR \"CB\" == \"O\" (False)\n# False or False or False or False -&gt; False\nprint(f\"Is atom '{atom_name_check}' a main chain atom? {is_main_chain_atom}\")\nprint(f\"Is atom '{atom_name_check}' NOT a main chain atom? {not is_main_chain_atom}\") # not False -&gt; True\n\nIs the residue hydrophobic AND surface exposed? False\nIs atom 'CB' a main chain atom? False\nIs atom 'CB' NOT a main chain atom? True\n\n\nAssignment Operators What they are: Used to assign values to variables.\nOperators:\n\n= (Assignment): The basic assignment operator.\n+= (Add and assign): x += yis equivalent to x = x + y.\n-= (Subtract and assign): x -= y is equivalent to x = x - y.\n*= (Multiply and assign): x *= y is equivalent to x = x * y.\n/= (Divide and assign): x /= yis equivalent to x = x / y.\nAnd others for floor division (//=), modulo (%=), exponentiation (**=).\n\nUse Cases:\n\nIncrementing counters: atom_count += 1.\nAccumulating sums: total_energy += current_interaction_energy.\nUpdating properties based on calculations.\n\n\nnum_hydrogen_bonds = 0\nprint(f\"Initial hydrogen bonds: {num_hydrogen_bonds}\")\n# ... some code finds a hydrogen bond ...\nnum_hydrogen_bonds += 1 # Increment by 1. Equivalent to: num_hydrogen_bonds = num_hydrogen_bonds + 1\nprint(f\"Number of hydrogen bonds found: {num_hydrogen_bonds}\")\n\nprotein_weight = 1000.0 # Initial hypothetical weight\n# During refinement, suppose a modification adds 50.0 Daltons\nprotein_weight += 50.0\nprint(f\"Updated protein weight: {protein_weight} Da\")\n\nInitial hydrogen bonds: 0\nNumber of hydrogen bonds found: 1\nUpdated protein weight: 1050.0 Da\n\n\nMembership Operators\nWhat they are: Used to test if a sequence (like a string, list, or tuple) contains a specific value.\nOperators: * in: Returns True if the value is found in the sequence. * not in: Returns True if the value is not found in the sequence.\nUse Cases in Structural Bioinformatics: * Checking if a specific amino acid is in a protein sequence: 'LYS' in protein_sequence. * Checking if a ligand ID (e.g., 'HOH' for water) is in a list of ligands found in a PDB file. * Checking if an atom name is in a list of known backbone atoms: atom_name in ['N', 'CA', 'C', 'O'].\n\nprotein_sequence_example = \"MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGG\"\nis_tryptophan_present = \"W\" in protein_sequence_example # W is Tryptophan: True\nprint(f\"Is Tryptophan ('W') in the sequence? {is_tryptophan_present}\")\n\nactive_site_residue_numbers = [45, 48, 97, 101, 152] # Example list of residue numbers\ncurrent_residue_num = 101\nis_in_active_site = current_residue_num in active_site_residue_numbers # 101 is in the list: True\nprint(f\"Is residue {current_residue_num} in the active site list? {is_in_active_site}\")\n\n# Check for a non-existent residue\nnon_existent_residue_num = 200\nis_not_in_active_site = non_existent_residue_num not in active_site_residue_numbers # 200 is not in the list: True\nprint(f\"Is residue {non_existent_residue_num} NOT in the active site list? {is_not_in_active_site}\")\n\nIs Tryptophan ('W') in the sequence? False\nIs residue 101 in the active site list? True\nIs residue 200 NOT in the active site list? True",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Fundamentals</span>"
    ]
  },
  {
    "objectID": "python-fundamentals.html#essential-built-in-functions",
    "href": "python-fundamentals.html#essential-built-in-functions",
    "title": "2  Python Fundamentals",
    "section": "2.3 Essential Built-in Functions",
    "text": "2.3 Essential Built-in Functions\nPython has many built-in functions that are always available for use without needing to import them from a module. These functions perform common tasks, making your coding more efficient. print():\nWhat it does: Displays output (text, variable values) to the console. This is your primary tool for seeing what your code is doing and for debugging.\nHow to use: You can pass multiple arguments separated by commas, and print() will separate them with a space by default.\n\nf-strings (formatted string literals): The most modern and recommended way to embed variable values directly into strings for printing. They start with an f before the opening quote, and variables are enclosed in curly braces {} within the string. You can also apply formatting (e.g., :.2f for two decimal places for a float).\nUse Cases:\nPrinting PDB ID, number of atoms, specific coordinates, results of calculations (e.g., print(f'Distance between atom {atom_serial_1} and atom {atom_serial_2}: {dist_value:.2f} Angstroms')). Providing progress updates during long analyses.\n\n\npdb_code_to_print = \"1TIM\"\nchain_id_to_print = \"A\"\nnum_residues_to_print = 248\n\n# Basic printing with commas\nprint(\"Analyzing structure\", pdb_code_to_print, \"chain\", chain_id_to_print)\n\n# Using an f-string for clear, embedded values and formatting\nprint(f\"Analyzing structure {pdb_code_to_print}, chain {chain_id_to_print}, which has {num_residues_to_print} residues.\")\n\n# Formatting a float in an f-string\ncalculated_rmsd = 1.23456\nprint(f\"The RMSD is {calculated_rmsd:.3f} Å.\") # Prints 1.235 (rounded to 3 decimal places)\n\nAnalyzing structure 1TIM chain A\nAnalyzing structure 1TIM, chain A, which has 248 residues.\nThe RMSD is 1.235 Å.\n\n\nExercise: Ask the user to input a residue number. Convert the input to an integer and print “You selected residue number: [number]”. Add a try-except block to handle a potential ValueError if the user doesn’t enter a valid number (e.g., they type “twenty” instead of “20”).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Fundamentals</span>"
    ]
  },
  {
    "objectID": "python-fundamentals2.html",
    "href": "python-fundamentals2.html",
    "title": "3  Operators: The Tools for Data Manipulation",
    "section": "",
    "text": "3.1 Essential Built-in Functions\nOperators are special symbols or keywords that perform operations on variables and values (called operands). Understanding operators is crucial for performing calculations, making comparisons, and combining conditions in your code.\nArithmetic Operators:\nUsed to perform mathematical calculations.\nOperators: * + (Addition) * - (Subtraction) * * (Multiplication) * / (True Division): Performs standard division, always returning a float (even if the result is a whole number).\nUse Cases in Structural Bioinformatics:\nExercise: Given x1 = 5.0, y1 = 10.0 and x2 = 8.0, y2 = 14.0. Calculate the squared distance in 2D: \\[(x2−x1)^2+(y2−y1)^2\\] Store the result in a variable sq_dist_2d and print it.\nComparison Operators:\nWhat they are: Used to compare two values. They always return a Boolean value (True or False).\nOperators:\nUse Cases in Structural Bioinformatics:\nExercise: A typical hydrogen bond length is between 2.7 and 3.3 Angstroms. Given measured_hbond_length = 2.9, write a comparison to check if it’s less than or equal to 3.3. Print the result.\nLogical Operators What they are: Used to combine multiple Boolean expressions. They also return a Boolean value (True or False).\nOperators:\nUse Cases in Structural Bioinformatics:\nAssignment Operators What they are: Used to assign values to variables.\nOperators:\nUse Cases:\nMembership Operators\nWhat they are: Used to test if a sequence (like a string, list, or tuple) contains a specific value.\nOperators: * in: Returns True if the value is found in the sequence. * not in: Returns True if the value is not found in the sequence.\nUse Cases in Structural Bioinformatics: * Checking if a specific amino acid is in a protein sequence: 'LYS' in protein_sequence. * Checking if a ligand ID (e.g., 'HOH' for water) is in a list of ligands found in a PDB file. * Checking if an atom name is in a list of known backbone atoms: atom_name in ['N', 'CA', 'C', 'O'].\nExercise: Given a list of common metal ions found in proteins: metal_ions = [“ZN”, “MG”, “FE”, “CA”]. Check if “CU” (Copper) is in this list. Then check if “MG” (Magnesium) is in this list. Print both boolean results.\nIdentity Operators: What they are: Used to compare if two variables refer to the exact same object in memory, not just if they have the same value.\nOperators:\nPython has many built-in functions that are always available for use without needing to import them from a module. These functions perform common tasks, making your coding more efficient. print():\nWhat it does: Displays output (text, variable values) to the console. This is your primary tool for seeing what your code is doing and for debugging.\nHow to use: You can pass multiple arguments separated by commas, and print() will separate them with a space by default. f-strings (formatted string literals): The most modern and recommended way to embed variable values directly into strings for printing. They start with an f before the opening quote, and variables are enclosed in curly braces {} within the string. You can also apply formatting (e.g., :.2f for two decimal places for a float). Use Cases: Printing PDB ID, number of atoms, specific coordinates, results of calculations (e.g., print(f’Distance between atom {atom_serial_1} and atom {atom_serial_2}: {dist_value:.2f} Angstroms’)). Providing progress updates during long analyses.\npdb_code_to_print = \"1TIM\"\nchain_id_to_print = \"A\"\nnum_residues_to_print = 248\n\n# Basic printing with commas\nprint(\"Analyzing structure\", pdb_code_to_print, \"chain\", chain_id_to_print)\n\n# Using an f-string for clear, embedded values and formatting\nprint(f\"Analyzing structure {pdb_code_to_print}, chain {chain_id_to_print}, which has {num_residues_to_print} residues.\")\n\n# Formatting a float in an f-string\ncalculated_rmsd = 1.23456\nprint(f\"The RMSD is {calculated_rmsd:.3f} Å.\") # Prints 1.235 (rounded to 3 decimal places)\n\nAnalyzing structure 1TIM chain A\nAnalyzing structure 1TIM, chain A, which has 248 residues.\nThe RMSD is 1.235 Å.",
    "crumbs": [
      "Python Fundamentals",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Operators: The Tools for Data Manipulation</span>"
    ]
  },
  {
    "objectID": "python-fundamentals1.html",
    "href": "python-fundamentals1.html",
    "title": "2  Variables and Data Types",
    "section": "",
    "text": "In programming, a variable is like a named container or a labeled box in your computer’s memory where you can store data. When you want to use that data later, you just refer to the variable’s name.\nPython is a dynamically typed language. This means you don’t need to explicitly tell Python what type of data a variable will hold (e.g., integer, text, decimal number) when you create it. Python automatically infers the type based on the value you assign. This makes Python very flexible and quicker to write for beginners, but it also means you need to be mindful of the data types you’re working with during operations.\nVariable Naming Rules (PEP 8 Style): To make your code readable and consistent (especially important when working with others or revisiting your own code later), follow these common conventions:\n\nLowercase with underscores (snake_case): This is the standard for variable and function names. Examples: pdb_id, atom_count, active_site_residues.\nStart with a letter or underscore: Variable names cannot begin with a number.\n\nValid: _temp_value, residue_10, chain_A.\nInvalid: 10_residues, 2nd_atom\n\nCase-sensitive: Python distinguishes between uppercase and lowercase letters. atom_name is a completely different variable from Atom_Name.\nAvoid Python keywords: Do not use words that Python reserves for its own syntax (e.g., if, for, list, def, return, True, False, None). Using them will cause a SyntaxError.\nBe descriptive: Choose names that clearly indicate the purpose or content of the variable. This makes your code much easier to understand.Good: active_site_residues, rmsd_value_angstroms, protein_sequenceBad: asr, x, p_seq\n\nCommon Data Types in Python for Structural Biology\nPython comes with several built-in data types that are fundamental for storing and manipulating information. Here are the most common ones you’ll encounter, with a focus on their applications in structural bioinformatics:\n\nIntegers (int): What they are: Whole numbers (positive, negative, or zero) without any fractional part.\nUse Cases in Structural Bioinformatics:\n\nCounting discrete entities: number_of_atoms = 4582, chain_count = 2.\nIdentifiers: residue_number = 101, atom_serial_number = 1560.\nSimulation steps: simulation_step = 50000.\n\n\n\nnumber_of_amino_acids = 287\natom_serial_number = 1560\n\nprint(f\"Number of amino acids: {number_of_amino_acids}\")\nprint(f\"Atom serial number: {atom_serial_number}\")\n\n# The type() function tells you what data type a variable holds\nprint(f\"Type of atom_serial_number: {type(atom_serial_number)}\") # Output: &lt;class 'int'&gt;\n\nNumber of amino acids: 287\nAtom serial number: 1560\nType of atom_serial_number: &lt;class 'int'&gt;\n\n\nExercise: Define a variable total_atoms_in_myoglobin and assign it an approximate number of atoms (e.g., 1260). Print the variable and its type.\n\nFloating-Point Numbers (float):\n\nWhat they are: Numbers that have a decimal point or are expressed in scientific notation. They are used to represent real numbers, often for measurements that are not whole numbers.\n\nUse Cases in Structural Bioinformatics:\nAtomic coordinates: x_coord = 12.345, y_coord = -4.567, z_coord = 18.901.\nMeasurements: RMSD values (rmsd_value = 1.5), B-factors (b_factor = 45.67), bond lengths (bond_length_angstroms = 1.54), solvent accessible surface area (SASA), resolution of crystal structures.\n\n\n# Atomic coordinates for a C-alpha atom\nca_x_coord = 10.253\nca_y_coord = -5.781\nca_z_coord = 22.019\nprint(f\"C-alpha coordinates: X={ca_x_coord}, Y={ca_y_coord}, Z={ca_z_coord}\")\n\nrmsd_to_native = 0.85 # Angstroms (Å is the symbol for Angstrom)\nprint(f\"RMSD to native structure: {rmsd_to_native} Å\")\nprint(f\"Type of rmsd_to_native: {type(rmsd_to_native)}\") # Output: &lt;class 'float'&gt;\n\nC-alpha coordinates: X=10.253, Y=-5.781, Z=22.019\nRMSD to native structure: 0.85 Å\nType of rmsd_to_native: &lt;class 'float'&gt;\n\n\nExercise: Define three float variables: coord_x = 10.123, coord_y = -4.567, coord_z = 18.901. Print these coordinates in a formatted string, perhaps like “Coordinates: (X: 10.123, Y: -4.567, Z: 18.901)”.\n\nStrings (str):\n\nWhat they are: Sequences of characters (text). Strings are immutable, meaning once created, their individual characters cannot be changed. Any operation that seems to modify a string actually creates a new string.\nHow to define strings:\n\nSingle quotes (‘…’) or Double quotes (“…”): Use these for single-line strings. It’s largely a matter of personal preference or team convention, but choose one and stick to it for consistency.\n\nIf your string contains an apostrophe, use double quotes to avoid issues (e.g., “It’s a protein”).\nIf your string contains double quotes, use single quotes (e.g., ‘The “alpha” carbon’).\n\nTriple quotes (“““…”“” or ’’‘…’’’): Use triple single or double quotes for multi-line strings. This is extremely useful for storing blocks of text, such as descriptions, help messages, or raw data snippets that span multiple lines, like a portion of a PDB file header or a long protein sequence.\n\nUse Cases in Structural Bioinformatics:\n\nPDB IDs: pdb_id = '1AKE', protein_data_bank_id = \"2HHB\".\nAtom names: atom_name = 'CA', element_symbol = \"C\".\nResidue names: residue_name = 'ALA', three_letter_code = \"GLY\".\nChain identifiers: chain_id = 'A'.\nBiological sequences: protein_sequence = \"MVLSEGEWQLVLHVWAKVEAD\", dna_sequence = \"ATGCGTAGCATG\".\nFile paths: pdb_file_path = \"data/1crn.pdb\".\nLines from data files: atom_record_line_pdb = \"ATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\".\n\n\nprotein_data_bank_id = \"2HHB\" # Hemoglobin\namino_acid_sequence_snippet = \"VLSPADKTNVKAAWGKVGAHAGEYGAEALE\"\n\n# A multi-line string for a simplified PDB ATOM record example\natom_record_line_pdb = \"\"\"\nATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\nATOM      2  CA  MET A   1      25.500  23.800  23.100  1.00 12.00           C\n\"\"\"\nprint(f\"Analyzing PDB ID: {protein_data_bank_id}\")\nprint(f\"Amino acid sequence snippet: {amino_acid_sequence_snippet}\")\nprint(f\"Example PDB ATOM line (multi-line): {atom_record_line_pdb}\")\nprint(f\"Type of protein_data_bank_id: {type(protein_data_bank_id)}\") # Output: &lt;class 'str'&gt;\n\nAnalyzing PDB ID: 2HHB\nAmino acid sequence snippet: VLSPADKTNVKAAWGKVGAHAGEYGAEALE\nExample PDB ATOM line (multi-line): \nATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\nATOM      2  CA  MET A   1      25.500  23.800  23.100  1.00 12.00           C\n\nType of protein_data_bank_id: &lt;class 'str'&gt;\n\n\nExercise: Create a string variable target_pdb_code and assign it \"1CBS\". Create another string variable ligand_name and assign it \"STI\" (a substrate analog for 1CBS). Print both variables in a sentence, e.g., “The target PDB is [code], and its ligand is [name].”\n\nBooleans (bool):\n\nWhat they are: Truth values. A boolean variable can only hold one of two possible values: True or False. These are special keywords in Python (notice the capital first letter). Booleans are the foundation of decision-making in your code.\nUse Cases in Structural Bioinformatics:\n\nFlags for presence/absence: is_ligand_present = True, has_hydrogen_atoms_in_pdb = False.\nResults of comparisons: resolution_ok = (pdb_resolution &lt; 2.0), is_distance_significant = (2.8 &lt; 3.5).\nCategorization: is_alpha_helix = True, is_clash_detected = False.\n\n\nis_structure_solved_by_xray = True\nhas_hydrogen_atoms_in_pdb = False # Often true for NMR, sometimes for high-res X-ray, but usually False for older X-ray PDBs\nis_distance_significant = (2.8 &lt; 3.5) # This is a comparison, which directly evaluates to True or False\nprint(f\"Structure solved by X-ray? {is_structure_solved_by_xray}\")\nprint(f\"Hydrogen atoms present? {has_hydrogen_atoms_in_pdb}\")\nprint(f\"Is the distance significant for an H-bond (2.8 &lt; 3.5)? {is_distance_significant}\")\nprint(f\"Type of is_distance_significant: {type(is_distance_significant)}\") # Output: &lt;class 'bool'&gt;\n\nStructure solved by X-ray? True\nHydrogen atoms present? False\nIs the distance significant for an H-bond (2.8 &lt; 3.5)? True\nType of is_distance_significant: &lt;class 'bool'&gt;\n\n\nExercise: Imagine you’ve calculated the B-factor of an atom as b_factor_value = 55.2. Create a boolean variable is_atom_flexible that is True if b_factor_value is greater than 50.0, and False otherwise. Print the value of is_atom_flexible.\n\nType Conversion (Casting):\n\nSometimes, you need to convert data from one type to another. This process is called “type conversion” or “casting.” Python provides built-in functions for this: int(), float(), str(), bool().\nContext in Structural Bioinformatics: A common scenario is when you read data from a file (like a PDB file). Although numbers (coordinates, B-factors, occupancy) are stored as text (strings) in the file, you’ll need to convert them to float or int to perform numerical calculations.\n\ncoordinate_str = \"12.345\" # This value is read as a string from a PDB file line\ncoordinate_float = float(coordinate_str) # Convert the string to a floating-point number\nprint(f\"Coordinate string '{coordinate_str}' as float: {coordinate_float}\")\nprint(f\"Type of coordinate_float: {type(coordinate_float)}\") # Output: &lt;class 'float'&gt;\n\natom_count_str = \"5000\"\natom_count_int = int(atom_count_str) # Convert the string to an integer\nprint(f\"Atom count '{atom_count_str}' as int: {atom_count_int}\")\nprint(atom_count_int * 2) # Now arithmetic operations are possible: 10000\n\n# Careful with float to int conversion: it truncates (chops off the decimal part), it does NOT round.\noccupancy_str = \"0.75\"\noccupancy_float = float(occupancy_str)\noccupancy_int_truncated = int(occupancy_float) # Becomes 0 (truncates 0.75 to 0)\nprint(f\"Occupancy '{occupancy_str}' as float: {occupancy_float}, as int (truncated): {occupancy_int_truncated}\")\n\n# Converting to boolean:\n# Most non-empty strings, non-zero numbers, non-empty lists/tuples/dictionaries evaluate to True\n# Empty strings, 0, None, empty lists/tuples/dictionaries evaluate to False\nis_present_str = \"True\"\nis_present_bool = bool(is_present_str) # This will be True because the string \"True\" is not empty\nprint(f\"'{is_present_str}' as boolean: {is_present_bool}\")\n\nempty_sequence_str = \"\"\nis_empty_bool = bool(empty_sequence_str) # This will be False\nprint(f\"'{empty_sequence_str}' as boolean: {is_empty_bool}\")\n\nCoordinate string '12.345' as float: 12.345\nType of coordinate_float: &lt;class 'float'&gt;\nAtom count '5000' as int: 5000\n10000\nOccupancy '0.75' as float: 0.75, as int (truncated): 0\n'True' as boolean: True\n'' as boolean: False",
    "crumbs": [
      "1. Python Fundamentals",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>python-fundamentals1</span>"
    ]
  },
  {
    "objectID": "python-fundamentals-1.html",
    "href": "python-fundamentals-1.html",
    "title": "2  Variables and Data Types",
    "section": "",
    "text": "In programming, a variable is like a named container or a labeled box in your computer’s memory where you can store data. When you want to use that data later, you just refer to the variable’s name.\nPython is a dynamically typed language. This means you don’t need to explicitly tell Python what type of data a variable will hold (e.g., integer, text, decimal number) when you create it. Python automatically infers the type based on the value you assign. This makes Python very flexible and quicker to write for beginners, but it also means you need to be mindful of the data types you’re working with during operations.\nVariable Naming Rules (PEP 8 Style): To make your code readable and consistent (especially important when working with others or revisiting your own code later), follow these common conventions:\n\nLowercase with underscores (snake_case): This is the standard for variable and function names. Examples: pdb_id, atom_count, active_site_residues.\nStart with a letter or underscore: Variable names cannot begin with a number.\n\nValid: _temp_value, residue_10, chain_A.\nInvalid: 10_residues, 2nd_atom\n\nCase-sensitive: Python distinguishes between uppercase and lowercase letters. atom_name is a completely different variable from Atom_Name.\nAvoid Python keywords: Do not use words that Python reserves for its own syntax (e.g., if, for, list, def, return, True, False, None). Using them will cause a SyntaxError.\nBe descriptive: Choose names that clearly indicate the purpose or content of the variable. This makes your code much easier to understand.Good: active_site_residues, rmsd_value_angstroms, protein_sequenceBad: asr, x, p_seq\n\nCommon Data Types in Python for Structural Biology\nPython comes with several built-in data types that are fundamental for storing and manipulating information. Here are the most common ones you’ll encounter, with a focus on their applications in structural bioinformatics:\n\nIntegers (int): What they are: Whole numbers (positive, negative, or zero) without any fractional part.\nUse Cases in Structural Bioinformatics:\n\nCounting discrete entities: number_of_atoms = 4582, chain_count = 2.\nIdentifiers: residue_number = 101, atom_serial_number = 1560.\nSimulation steps: simulation_step = 50000.\n\n\n\nnumber_of_amino_acids = 287\natom_serial_number = 1560\n\nprint(f\"Number of amino acids: {number_of_amino_acids}\")\nprint(f\"Atom serial number: {atom_serial_number}\")\n\n# The type() function tells you what data type a variable holds\nprint(f\"Type of atom_serial_number: {type(atom_serial_number)}\") # Output: &lt;class 'int'&gt;\n\nNumber of amino acids: 287\nAtom serial number: 1560\nType of atom_serial_number: &lt;class 'int'&gt;\n\n\nExercise: Define a variable total_atoms_in_myoglobin and assign it an approximate number of atoms (e.g., 1260). Print the variable and its type.\n\nFloating-Point Numbers (float):\n\nWhat they are: Numbers that have a decimal point or are expressed in scientific notation. They are used to represent real numbers, often for measurements that are not whole numbers.\n\nUse Cases in Structural Bioinformatics:\nAtomic coordinates: x_coord = 12.345, y_coord = -4.567, z_coord = 18.901.\nMeasurements: RMSD values (rmsd_value = 1.5), B-factors (b_factor = 45.67), bond lengths (bond_length_angstroms = 1.54), solvent accessible surface area (SASA), resolution of crystal structures.\n\n\n# Atomic coordinates for a C-alpha atom\nca_x_coord = 10.253\nca_y_coord = -5.781\nca_z_coord = 22.019\nprint(f\"C-alpha coordinates: X={ca_x_coord}, Y={ca_y_coord}, Z={ca_z_coord}\")\n\nrmsd_to_native = 0.85 # Angstroms (Å is the symbol for Angstrom)\nprint(f\"RMSD to native structure: {rmsd_to_native} Å\")\nprint(f\"Type of rmsd_to_native: {type(rmsd_to_native)}\") # Output: &lt;class 'float'&gt;\n\nC-alpha coordinates: X=10.253, Y=-5.781, Z=22.019\nRMSD to native structure: 0.85 Å\nType of rmsd_to_native: &lt;class 'float'&gt;\n\n\nExercise: Define three float variables: coord_x = 10.123, coord_y = -4.567, coord_z = 18.901. Print these coordinates in a formatted string, perhaps like “Coordinates: (X: 10.123, Y: -4.567, Z: 18.901)”.\n\nStrings (str):\n\nWhat they are: Sequences of characters (text). Strings are immutable, meaning once created, their individual characters cannot be changed. Any operation that seems to modify a string actually creates a new string.\nHow to define strings:\n\nSingle quotes (‘…’) or Double quotes (“…”): Use these for single-line strings. It’s largely a matter of personal preference or team convention, but choose one and stick to it for consistency.\n\nIf your string contains an apostrophe, use double quotes to avoid issues (e.g., “It’s a protein”).\nIf your string contains double quotes, use single quotes (e.g., ‘The “alpha” carbon’).\n\nTriple quotes (“““…”“” or ’’‘…’’’): Use triple single or double quotes for multi-line strings. This is extremely useful for storing blocks of text, such as descriptions, help messages, or raw data snippets that span multiple lines, like a portion of a PDB file header or a long protein sequence.\n\nUse Cases in Structural Bioinformatics:\n\nPDB IDs: pdb_id = '1AKE', protein_data_bank_id = \"2HHB\".\nAtom names: atom_name = 'CA', element_symbol = \"C\".\nResidue names: residue_name = 'ALA', three_letter_code = \"GLY\".\nChain identifiers: chain_id = 'A'.\nBiological sequences: protein_sequence = \"MVLSEGEWQLVLHVWAKVEAD\", dna_sequence = \"ATGCGTAGCATG\".\nFile paths: pdb_file_path = \"data/1crn.pdb\".\nLines from data files: atom_record_line_pdb = \"ATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\".\n\n\nprotein_data_bank_id = \"2HHB\" # Hemoglobin\namino_acid_sequence_snippet = \"VLSPADKTNVKAAWGKVGAHAGEYGAEALE\"\n\n# A multi-line string for a simplified PDB ATOM record example\natom_record_line_pdb = \"\"\"\nATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\nATOM      2  CA  MET A   1      25.500  23.800  23.100  1.00 12.00           C\n\"\"\"\nprint(f\"Analyzing PDB ID: {protein_data_bank_id}\")\nprint(f\"Amino acid sequence snippet: {amino_acid_sequence_snippet}\")\nprint(f\"Example PDB ATOM line (multi-line): {atom_record_line_pdb}\")\nprint(f\"Type of protein_data_bank_id: {type(protein_data_bank_id)}\") # Output: &lt;class 'str'&gt;\n\nAnalyzing PDB ID: 2HHB\nAmino acid sequence snippet: VLSPADKTNVKAAWGKVGAHAGEYGAEALE\nExample PDB ATOM line (multi-line): \nATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\nATOM      2  CA  MET A   1      25.500  23.800  23.100  1.00 12.00           C\n\nType of protein_data_bank_id: &lt;class 'str'&gt;\n\n\nExercise: Create a string variable target_pdb_code and assign it \"1CBS\". Create another string variable ligand_name and assign it \"STI\" (a substrate analog for 1CBS). Print both variables in a sentence, e.g., “The target PDB is [code], and its ligand is [name].”\n\nBooleans (bool):\n\nWhat they are: Truth values. A boolean variable can only hold one of two possible values: True or False. These are special keywords in Python (notice the capital first letter). Booleans are the foundation of decision-making in your code.\nUse Cases in Structural Bioinformatics:\n\nFlags for presence/absence: is_ligand_present = True, has_hydrogen_atoms_in_pdb = False.\nResults of comparisons: resolution_ok = (pdb_resolution &lt; 2.0), is_distance_significant = (2.8 &lt; 3.5).\nCategorization: is_alpha_helix = True, is_clash_detected = False.\n\n\nis_structure_solved_by_xray = True\nhas_hydrogen_atoms_in_pdb = False # Often true for NMR, sometimes for high-res X-ray, but usually False for older X-ray PDBs\nis_distance_significant = (2.8 &lt; 3.5) # This is a comparison, which directly evaluates to True or False\nprint(f\"Structure solved by X-ray? {is_structure_solved_by_xray}\")\nprint(f\"Hydrogen atoms present? {has_hydrogen_atoms_in_pdb}\")\nprint(f\"Is the distance significant for an H-bond (2.8 &lt; 3.5)? {is_distance_significant}\")\nprint(f\"Type of is_distance_significant: {type(is_distance_significant)}\") # Output: &lt;class 'bool'&gt;\n\nStructure solved by X-ray? True\nHydrogen atoms present? False\nIs the distance significant for an H-bond (2.8 &lt; 3.5)? True\nType of is_distance_significant: &lt;class 'bool'&gt;\n\n\nExercise: Imagine you’ve calculated the B-factor of an atom as b_factor_value = 55.2. Create a boolean variable is_atom_flexible that is True if b_factor_value is greater than 50.0, and False otherwise. Print the value of is_atom_flexible.\n\nType Conversion (Casting):\n\nSometimes, you need to convert data from one type to another. This process is called “type conversion” or “casting.” Python provides built-in functions for this: int(), float(), str(), bool().\nContext in Structural Bioinformatics: A common scenario is when you read data from a file (like a PDB file). Although numbers (coordinates, B-factors, occupancy) are stored as text (strings) in the file, you’ll need to convert them to float or int to perform numerical calculations.\n\ncoordinate_str = \"12.345\" # This value is read as a string from a PDB file line\ncoordinate_float = float(coordinate_str) # Convert the string to a floating-point number\nprint(f\"Coordinate string '{coordinate_str}' as float: {coordinate_float}\")\nprint(f\"Type of coordinate_float: {type(coordinate_float)}\") # Output: &lt;class 'float'&gt;\n\natom_count_str = \"5000\"\natom_count_int = int(atom_count_str) # Convert the string to an integer\nprint(f\"Atom count '{atom_count_str}' as int: {atom_count_int}\")\nprint(atom_count_int * 2) # Now arithmetic operations are possible: 10000\n\n# Careful with float to int conversion: it truncates (chops off the decimal part), it does NOT round.\noccupancy_str = \"0.75\"\noccupancy_float = float(occupancy_str)\noccupancy_int_truncated = int(occupancy_float) # Becomes 0 (truncates 0.75 to 0)\nprint(f\"Occupancy '{occupancy_str}' as float: {occupancy_float}, as int (truncated): {occupancy_int_truncated}\")\n\n# Converting to boolean:\n# Most non-empty strings, non-zero numbers, non-empty lists/tuples/dictionaries evaluate to True\n# Empty strings, 0, None, empty lists/tuples/dictionaries evaluate to False\nis_present_str = \"True\"\nis_present_bool = bool(is_present_str) # This will be True because the string \"True\" is not empty\nprint(f\"'{is_present_str}' as boolean: {is_present_bool}\")\n\nempty_sequence_str = \"\"\nis_empty_bool = bool(empty_sequence_str) # This will be False\nprint(f\"'{empty_sequence_str}' as boolean: {is_empty_bool}\")\n\nCoordinate string '12.345' as float: 12.345\nType of coordinate_float: &lt;class 'float'&gt;\nAtom count '5000' as int: 5000\n10000\nOccupancy '0.75' as float: 0.75, as int (truncated): 0\n'True' as boolean: True\n'' as boolean: False",
    "crumbs": [
      "Python Fundamentals",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Data Types</span>"
    ]
  },
  {
    "objectID": "python-fundamentals.html#variables-and-data-types-1",
    "href": "python-fundamentals.html#variables-and-data-types-1",
    "title": "2  Python Fundamentals",
    "section": "2.3 Variables and Data Types",
    "text": "2.3 Variables and Data Types\nIn programming, a variable is like a named container or a labeled box in your computer’s memory where you can store data. When you want to use that data later, you just refer to the variable’s name.\nPython is a dynamically typed language. This means you don’t need to explicitly tell Python what type of data a variable will hold (e.g., integer, text, decimal number) when you create it. Python automatically infers the type based on the value you assign. This makes Python very flexible and quicker to write for beginners, but it also means you need to be mindful of the data types you’re working with during operations.\nVariable Naming Rules (PEP 8 Style): To make your code readable and consistent (especially important when working with others or revisiting your own code later), follow these common conventions:\n\nLowercase with underscores (snake_case): This is the standard for variable and function names. Examples: pdb_id, atom_count, active_site_residues.\nStart with a letter or underscore: Variable names cannot begin with a number.\n\nValid: _temp_value, residue_10, chain_A.\nInvalid: 10_residues, 2nd_atom\n\nCase-sensitive: Python distinguishes between uppercase and lowercase letters. atom_name is a completely different variable from Atom_Name.\nAvoid Python keywords: Do not use words that Python reserves for its own syntax (e.g., if, for, list, def, return, True, False, None). Using them will cause a SyntaxError.\nBe descriptive: Choose names that clearly indicate the purpose or content of the variable. This makes your code much easier to understand.Good: active_site_residues, rmsd_value_angstroms, protein_sequenceBad: asr, x, p_seq\n\nCommon Data Types in Python for Structural Biology\nPython comes with several built-in data types that are fundamental for storing and manipulating information. Here are the most common ones you’ll encounter, with a focus on their applications in structural bioinformatics:\n\nIntegers (int): What they are: Whole numbers (positive, negative, or zero) without any fractional part.\nUse Cases in Structural Bioinformatics:\n\nCounting discrete entities: number_of_atoms = 4582, chain_count = 2.\nIdentifiers: residue_number = 101, atom_serial_number = 1560.\nSimulation steps: simulation_step = 50000.\n\n\n\nnumber_of_amino_acids = 287\natom_serial_number = 1560\n\nprint(f\"Number of amino acids: {number_of_amino_acids}\")\nprint(f\"Atom serial number: {atom_serial_number}\")\n\n# The type() function tells you what data type a variable holds\nprint(f\"Type of atom_serial_number: {type(atom_serial_number)}\") # Output: &lt;class 'int'&gt;\n\nNumber of amino acids: 287\nAtom serial number: 1560\nType of atom_serial_number: &lt;class 'int'&gt;\n\n\nExercise: Define a variable total_atoms_in_myoglobin and assign it an approximate number of atoms (e.g., 1260). Print the variable and its type.\n\nFloating-Point Numbers (float):\n\nWhat they are: Numbers that have a decimal point or are expressed in scientific notation. They are used to represent real numbers, often for measurements that are not whole numbers.\n\nUse Cases in Structural Bioinformatics:\nAtomic coordinates: x_coord = 12.345, y_coord = -4.567, z_coord = 18.901.\nMeasurements: RMSD values (rmsd_value = 1.5), B-factors (b_factor = 45.67), bond lengths (bond_length_angstroms = 1.54), solvent accessible surface area (SASA), resolution of crystal structures.\n\n\n# Atomic coordinates for a C-alpha atom\nca_x_coord = 10.253\nca_y_coord = -5.781\nca_z_coord = 22.019\nprint(f\"C-alpha coordinates: X={ca_x_coord}, Y={ca_y_coord}, Z={ca_z_coord}\")\n\nrmsd_to_native = 0.85 # Angstroms (Å is the symbol for Angstrom)\nprint(f\"RMSD to native structure: {rmsd_to_native} Å\")\nprint(f\"Type of rmsd_to_native: {type(rmsd_to_native)}\") # Output: &lt;class 'float'&gt;\n\nC-alpha coordinates: X=10.253, Y=-5.781, Z=22.019\nRMSD to native structure: 0.85 Å\nType of rmsd_to_native: &lt;class 'float'&gt;\n\n\nExercise: Define three float variables: coord_x = 10.123, coord_y = -4.567, coord_z = 18.901. Print these coordinates in a formatted string, perhaps like “Coordinates: (X: 10.123, Y: -4.567, Z: 18.901)”.\n\nStrings (str):\n\nWhat they are: Sequences of characters (text). Strings are immutable, meaning once created, their individual characters cannot be changed. Any operation that seems to modify a string actually creates a new string.\nHow to define strings:\n\nSingle quotes (‘…’) or Double quotes (“…”): Use these for single-line strings. It’s largely a matter of personal preference or team convention, but choose one and stick to it for consistency.\n\nIf your string contains an apostrophe, use double quotes to avoid issues (e.g., “It’s a protein”).\nIf your string contains double quotes, use single quotes (e.g., ‘The “alpha” carbon’).\n\nTriple quotes (“““…”“” or ’’‘…’’’): Use triple single or double quotes for multi-line strings. This is extremely useful for storing blocks of text, such as descriptions, help messages, or raw data snippets that span multiple lines, like a portion of a PDB file header or a long protein sequence.\n\nUse Cases in Structural Bioinformatics:\n\nPDB IDs: pdb_id = '1AKE', protein_data_bank_id = \"2HHB\".\nAtom names: atom_name = 'CA', element_symbol = \"C\".\nResidue names: residue_name = 'ALA', three_letter_code = \"GLY\".\nChain identifiers: chain_id = 'A'.\nBiological sequences: protein_sequence = \"MVLSEGEWQLVLHVWAKVEAD\", dna_sequence = \"ATGCGTAGCATG\".\nFile paths: pdb_file_path = \"data/1crn.pdb\".\nLines from data files: atom_record_line_pdb = \"ATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\".\n\n\nprotein_data_bank_id = \"2HHB\" # Hemoglobin\namino_acid_sequence_snippet = \"VLSPADKTNVKAAWGKVGAHAGEYGAEALE\"\n\n# A multi-line string for a simplified PDB ATOM record example\natom_record_line_pdb = \"\"\"\nATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\nATOM      2  CA  MET A   1      25.500  23.800  23.100  1.00 12.00           C\n\"\"\"\nprint(f\"Analyzing PDB ID: {protein_data_bank_id}\")\nprint(f\"Amino acid sequence snippet: {amino_acid_sequence_snippet}\")\nprint(f\"Example PDB ATOM line (multi-line): {atom_record_line_pdb}\")\nprint(f\"Type of protein_data_bank_id: {type(protein_data_bank_id)}\") # Output: &lt;class 'str'&gt;\n\nAnalyzing PDB ID: 2HHB\nAmino acid sequence snippet: VLSPADKTNVKAAWGKVGAHAGEYGAEALE\nExample PDB ATOM line (multi-line): \nATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\nATOM      2  CA  MET A   1      25.500  23.800  23.100  1.00 12.00           C\n\nType of protein_data_bank_id: &lt;class 'str'&gt;\n\n\nExercise: Create a string variable target_pdb_code and assign it \"1CBS\". Create another string variable ligand_name and assign it \"STI\" (a substrate analog for 1CBS). Print both variables in a sentence, e.g., “The target PDB is [code], and its ligand is [name].”\n\nBooleans (bool):\n\nWhat they are: Truth values. A boolean variable can only hold one of two possible values: True or False. These are special keywords in Python (notice the capital first letter). Booleans are the foundation of decision-making in your code.\nUse Cases in Structural Bioinformatics:\n\nFlags for presence/absence: is_ligand_present = True, has_hydrogen_atoms_in_pdb = False.\nResults of comparisons: resolution_ok = (pdb_resolution &lt; 2.0), is_distance_significant = (2.8 &lt; 3.5).\nCategorization: is_alpha_helix = True, is_clash_detected = False.\n\n\nis_structure_solved_by_xray = True\nhas_hydrogen_atoms_in_pdb = False # Often true for NMR, sometimes for high-res X-ray, but usually False for older X-ray PDBs\nis_distance_significant = (2.8 &lt; 3.5) # This is a comparison, which directly evaluates to True or False\nprint(f\"Structure solved by X-ray? {is_structure_solved_by_xray}\")\nprint(f\"Hydrogen atoms present? {has_hydrogen_atoms_in_pdb}\")\nprint(f\"Is the distance significant for an H-bond (2.8 &lt; 3.5)? {is_distance_significant}\")\nprint(f\"Type of is_distance_significant: {type(is_distance_significant)}\") # Output: &lt;class 'bool'&gt;\n\nStructure solved by X-ray? True\nHydrogen atoms present? False\nIs the distance significant for an H-bond (2.8 &lt; 3.5)? True\nType of is_distance_significant: &lt;class 'bool'&gt;\n\n\nExercise: Imagine you’ve calculated the B-factor of an atom as b_factor_value = 55.2. Create a boolean variable is_atom_flexible that is True if b_factor_value is greater than 50.0, and False otherwise. Print the value of is_atom_flexible.\n\nType Conversion (Casting):\n\nSometimes, you need to convert data from one type to another. This process is called “type conversion” or “casting.” Python provides built-in functions for this: int(), float(), str(), bool().\nContext in Structural Bioinformatics: A common scenario is when you read data from a file (like a PDB file). Although numbers (coordinates, B-factors, occupancy) are stored as text (strings) in the file, you’ll need to convert them to float or int to perform numerical calculations.\n\ncoordinate_str = \"12.345\" # This value is read as a string from a PDB file line\ncoordinate_float = float(coordinate_str) # Convert the string to a floating-point number\nprint(f\"Coordinate string '{coordinate_str}' as float: {coordinate_float}\")\nprint(f\"Type of coordinate_float: {type(coordinate_float)}\") # Output: &lt;class 'float'&gt;\n\natom_count_str = \"5000\"\natom_count_int = int(atom_count_str) # Convert the string to an integer\nprint(f\"Atom count '{atom_count_str}' as int: {atom_count_int}\")\nprint(atom_count_int * 2) # Now arithmetic operations are possible: 10000\n\n# Careful with float to int conversion: it truncates (chops off the decimal part), it does NOT round.\noccupancy_str = \"0.75\"\noccupancy_float = float(occupancy_str)\noccupancy_int_truncated = int(occupancy_float) # Becomes 0 (truncates 0.75 to 0)\nprint(f\"Occupancy '{occupancy_str}' as float: {occupancy_float}, as int (truncated): {occupancy_int_truncated}\")\n\n# Converting to boolean:\n# Most non-empty strings, non-zero numbers, non-empty lists/tuples/dictionaries evaluate to True\n# Empty strings, 0, None, empty lists/tuples/dictionaries evaluate to False\nis_present_str = \"True\"\nis_present_bool = bool(is_present_str) # This will be True because the string \"True\" is not empty\nprint(f\"'{is_present_str}' as boolean: {is_present_bool}\")\n\nempty_sequence_str = \"\"\nis_empty_bool = bool(empty_sequence_str) # This will be False\nprint(f\"'{empty_sequence_str}' as boolean: {is_empty_bool}\")\n\nCoordinate string '12.345' as float: 12.345\nType of coordinate_float: &lt;class 'float'&gt;\nAtom count '5000' as int: 5000\n10000\nOccupancy '0.75' as float: 0.75, as int (truncated): 0\n'True' as boolean: True\n'' as boolean: False",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Fundamentals</span>"
    ]
  },
  {
    "objectID": "python-fundamentals.html#operators-the-tools-for-data-manipulation-1",
    "href": "python-fundamentals.html#operators-the-tools-for-data-manipulation-1",
    "title": "2  Python Fundamentals",
    "section": "2.4 Operators: The Tools for Data Manipulation",
    "text": "2.4 Operators: The Tools for Data Manipulation\nOperators are special symbols or keywords that perform operations on variables and values (called operands). Understanding operators is crucial for performing calculations, making comparisons, and combining conditions in your code.\nArithmetic Operators:\nUsed to perform mathematical calculations.\nOperators: * + (Addition) * - (Subtraction) * * (Multiplication) * / (True Division): Performs standard division, always returning a float (even if the result is a whole number).\n\n// (Floor Division): Performs division and returns the integer part of the quotient (rounds down to the nearest whole number).\n% (Modulo): Returns the remainder of a division.\n** (Exponentiation): Raises the first operand to the power of the second.\n\nUse Cases in Structural Bioinformatics:\n\nCalculating distances between atoms (e.g., Euclidean distance:\nAveraging B-factors or other numerical properties.\nScaling coordinates.\nCalculating molecular weights (summing up atomic weights).\n\n\n# Simplified distance calculation in 1D for now\natom1_x = 10.0\natom2_x = 15.5\ndelta_x = atom2_x - atom1_x # Difference in X-coordinate: 5.5\ndistance_sq_x = delta_x ** 2 # Square of the difference: 5.5 * 5.5 = 30.25\nprint(f\"Difference in X: {delta_x}, Squared difference: {distance_sq_x}\")\n\n# Average B-factor of two atoms\nb_factor1 = 20.5\nb_factor2 = 30.1\naverage_b_factor = (b_factor1 + b_factor2) / 2 # Division results in float: 25.3\nprint(f\"Average B-factor: {average_b_factor}\")\n\nsequence_length = 101 # Example: number of residues\nresidues_per_turn_helix = 3.6 # Approximate number of residues per turn in an alpha-helix\napprox_turns = sequence_length / residues_per_turn_helix # True division: 101 / 3.6 = 28.055...\nfull_turns = sequence_length // residues_per_turn_helix # Floor division: 101 // 3.6 = 28.0 (type is float but value is integer part)\n# Note: If both operands are integers, // returns an integer. If either is float, it returns a float.\nprint(f\"Approximate turns in helix: {approx_turns:.2f}, Full turns: {full_turns}\")\n\nremainder_check = 10 % 3 # Modulo: 10 divided by 3 is 3 with a remainder of 1\nprint(f\"Remainder of 10 / 3: {remainder_check}\") # Output: 1\n\nDifference in X: 5.5, Squared difference: 30.25\nAverage B-factor: 25.3\nApproximate turns in helix: 28.06, Full turns: 28.0\nRemainder of 10 / 3: 1\n\n\nExercise: Given x1 = 5.0, y1 = 10.0 and x2 = 8.0, y2 = 14.0. Calculate the squared distance in 2D: \\[(x2−x1)^2+(y2−y1)^2\\] Store the result in a variable sq_dist_2d and print it.\nComparison Operators:\nWhat they are: Used to compare two values. They always return a Boolean value (True or False).\nOperators:\n\n== (Equal to): Returns True if two operands have the same value.\n!= (Not equal to): Returns True if two operands have different values.\n&gt; (Greater than)\n&lt; (Less than)\n&gt;= (Greater than or equal to)\n&lt;= (Less than or equal to)\n\nUse Cases in Structural Bioinformatics:\n\nComparing resolution values: resolution1 &lt; resolution2.\nChecking if a B-factor exceeds a threshold: b_factor &gt; 70.0.\nComparing atom names: atom_name == 'CA'.\nChecking if a residue number is within a specific range: residue_number &gt;= 10 and residue_number &lt;= 20.\n\n\nmy_protein_resolution = 1.8 # Angstroms\nacceptable_resolution_max = 2.5\nis_good_resolution = my_protein_resolution &lt;= acceptable_resolution_max # 1.8 is less than or equal to 2.5, so True\nprint(f\"Is resolution {my_protein_resolution}Å acceptable (&lt;= {acceptable_resolution_max}Å)? {is_good_resolution}\")\n\natom_type = \"C\"\nis_carbon_atom = atom_type == \"C\" # Is \"C\" equal to \"C\"? True\nprint(f\"Is atom_type '{atom_type}' a Carbon? {is_carbon_atom}\")\n\n# Check if a chain ID is not 'X' (often used for unknown chains)\nchain_id = \"A\"\nis_not_unknown_chain = chain_id != \"X\" # \"A\" is not equal to \"X\", so True\nprint(f\"Is chain '{chain_id}' not an unknown chain? {is_not_unknown_chain}\")\n\nIs resolution 1.8Å acceptable (&lt;= 2.5Å)? True\nIs atom_type 'C' a Carbon? True\nIs chain 'A' not an unknown chain? True\n\n\nExercise: A typical hydrogen bond length is between 2.7 and 3.3 Angstroms. Given measured_hbond_length = 2.9, write a comparison to check if it’s less than or equal to 3.3. Print the result.\nLogical Operators What they are: Used to combine multiple Boolean expressions. They also return a Boolean value (True or False).\nOperators:\n\nand: Returns True if both operands are True.\nor: Returns True if at least one of the operands is True.\nnot: Reverses the logical state of its operand (if True becomes False, if False becomes True).\n\nUse Cases in Structural Bioinformatics:\n\nChecking if a residue is part of an alpha-helix AND is solvent exposed: is_helix and is_exposed.\nChecking if an atom is a backbone atom (C-alpha OR N OR C OR O): (atom_name == 'CA') or (atom_name == 'N') or (atom_name == 'C') or (atom_name == 'O').\nChecking if a structure is not an NMR structure: not (experimental_method == 'NMR').\n\n\nis_hydrophobic_residue = True\nis_surface_exposed = False\n# Is it a surface-exposed hydrophobic residue? Both conditions must be True.\nis_hydrophobic_and_surface = is_hydrophobic_residue and is_surface_exposed # True and False -&gt; False\nprint(f\"Is the residue hydrophobic AND surface exposed? {is_hydrophobic_and_surface}\")\n\natom_name_check = \"CB\" # C-beta\n# Is it a main chain atom? (N, CA, C, or O)\nis_main_chain_atom = (atom_name_check == \"N\" or atom_name_check == \"CA\" or atom_name_check == \"C\" or atom_name_check == \"O\")\n# \"CB\" == \"N\" (False) OR \"CB\" == \"CA\" (False) OR \"CB\" == \"C\" (False) OR \"CB\" == \"O\" (False)\n# False or False or False or False -&gt; False\nprint(f\"Is atom '{atom_name_check}' a main chain atom? {is_main_chain_atom}\")\nprint(f\"Is atom '{atom_name_check}' NOT a main chain atom? {not is_main_chain_atom}\") # not False -&gt; True\n\nIs the residue hydrophobic AND surface exposed? False\nIs atom 'CB' a main chain atom? False\nIs atom 'CB' NOT a main chain atom? True\n\n\nAssignment Operators What they are: Used to assign values to variables.\nOperators:\n\n= (Assignment): The basic assignment operator.\n+= (Add and assign): x += yis equivalent to x = x + y.\n-= (Subtract and assign): x -= y is equivalent to x = x - y.\n*= (Multiply and assign): x *= y is equivalent to x = x * y.\n/= (Divide and assign): x /= yis equivalent to x = x / y.\nAnd others for floor division (//=), modulo (%=), exponentiation (**=).\n\nUse Cases:\n\nIncrementing counters: atom_count += 1.\nAccumulating sums: total_energy += current_interaction_energy.\nUpdating properties based on calculations.\n\n\nnum_hydrogen_bonds = 0\nprint(f\"Initial hydrogen bonds: {num_hydrogen_bonds}\")\n# ... some code finds a hydrogen bond ...\nnum_hydrogen_bonds += 1 # Increment by 1. Equivalent to: num_hydrogen_bonds = num_hydrogen_bonds + 1\nprint(f\"Number of hydrogen bonds found: {num_hydrogen_bonds}\")\n\nprotein_weight = 1000.0 # Initial hypothetical weight\n# During refinement, suppose a modification adds 50.0 Daltons\nprotein_weight += 50.0\nprint(f\"Updated protein weight: {protein_weight} Da\")\n\nInitial hydrogen bonds: 0\nNumber of hydrogen bonds found: 1\nUpdated protein weight: 1050.0 Da\n\n\nMembership Operators\nWhat they are: Used to test if a sequence (like a string, list, or tuple) contains a specific value.\nOperators: * in: Returns True if the value is found in the sequence. * not in: Returns True if the value is not found in the sequence.\nUse Cases in Structural Bioinformatics: * Checking if a specific amino acid is in a protein sequence: 'LYS' in protein_sequence. * Checking if a ligand ID (e.g., 'HOH' for water) is in a list of ligands found in a PDB file. * Checking if an atom name is in a list of known backbone atoms: atom_name in ['N', 'CA', 'C', 'O'].\n\nprotein_sequence_example = \"MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGG\"\nis_tryptophan_present = \"W\" in protein_sequence_example # W is Tryptophan: True\nprint(f\"Is Tryptophan ('W') in the sequence? {is_tryptophan_present}\")\n\nactive_site_residue_numbers = [45, 48, 97, 101, 152] # Example list of residue numbers\ncurrent_residue_num = 101\nis_in_active_site = current_residue_num in active_site_residue_numbers # 101 is in the list: True\nprint(f\"Is residue {current_residue_num} in the active site list? {is_in_active_site}\")\n\n# Check for a non-existent residue\nnon_existent_residue_num = 200\nis_not_in_active_site = non_existent_residue_num not in active_site_residue_numbers # 200 is not in the list: True\nprint(f\"Is residue {non_existent_residue_num} NOT in the active site list? {is_not_in_active_site}\")\n\nIs Tryptophan ('W') in the sequence? False\nIs residue 101 in the active site list? True\nIs residue 200 NOT in the active site list? True\n\n\nExercise: Given a list of common metal ions found in proteins: metal_ions = [“ZN”, “MG”, “FE”, “CA”]. Check if “CU” (Copper) is in this list. Then check if “MG” (Magnesium) is in this list. Print both boolean results.\nIdentity Operators: What they are: Used to compare if two variables refer to the exact same object in memory, not just if they have the same value.\nOperators:\n\nis: Returns True if both variables point to the same object.\nis not: Returns True if both variables do not point to the same object.\nNote: For comparing values (e.g., if two numbers or strings are equal), you almost always want to use == (equality operator). The is operator is more subtle and less frequently used for basic value checks by beginners. It becomes relevant when you are dealing with object references, especially for mutable objects like lists.\n\n\nlist_a = [10, 20, 30]\nlist_b = [10, 20, 30] # list_b has the same values as list_a, but it's a *different object* in memory\nlist_c = list_a      # list_c is assigned to *refer to the same object* as list_a\n\nprint(f\"list_a == list_b (value equality): {list_a == list_b}\") # True (values are the same)\nprint(f\"list_a is list_b (identity): {list_a is list_b}\")     # False (they are distinct objects)\nprint(f\"list_a is list_c (identity): {list_a is list_c}\")     # True (they refer to the same object)\n\n# Let's see the effect of modifying list_c\nlist_c.append(40)\nprint(f\"List A after modifying C: {list_a}\") # Output: [10, 20, 30, 40] - list_a was also changed!\n\nlist_a == list_b (value equality): True\nlist_a is list_b (identity): False\nlist_a is list_c (identity): True\nList A after modifying C: [10, 20, 30, 40]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Fundamentals</span>"
    ]
  },
  {
    "objectID": "python-fundamentals.html#control-flow-directing-your-codes-path",
    "href": "python-fundamentals.html#control-flow-directing-your-codes-path",
    "title": "2  Python Fundamentals",
    "section": "2.4 Control Flow: Directing Your Code’s Path",
    "text": "2.4 Control Flow: Directing Your Code’s Path\nControl flow statements determine the order in which the lines of your code are executed. Without control flow, your program would simply execute line by line from top to bottom. Control flow allows your program to make decisions, repeat actions, and respond dynamically to data, which is essential for any non-trivial task in structural bioinformatics.\n\n2.4.1 Conditional Statements: if, elif, else\nConditional statements allow your program to make decisions and execute different blocks of code based on whether certain conditions are True or False. This enables your code to behave dynamically depending on the data it is processing or the state of your program.\n\nif statement: Purpose: Executes a block of code only if a specified condition is True.\n\nSyntax: if condition: # Code to execute if condition is True statement1 statement2\n\nThe condition is any expression that evaluates to True or False (e.g., x &gt; 10, atom_name == \"CA\", is_ligand_present). The indented block of code (often called the “suite”) is executed only if the condition is True.\nelif (else if) statement: Purpose: Used after an if (or another elif) to check an additional condition only if all preceding if or elif conditions were False. You can have any number of elif blocks.\n\nSyntax: if condition1: # Code if condition1 is True elif condition2: # Only checked if condition1 was False # Code if condition2 is True\n\nelse statement: Purpose: An optional final block that executes if none of the preceding if or elif conditions were True. It acts as a “catch-all” or default action.\n\nSyntax: if condition1: # Code if condition1 is True elif condition2: # Code if condition2 is True else: # Only executed if condition1 and condition2 were both False # Default code\nImportant Indentation: Python uses indentation (typically 4 spaces) to define code blocks. This is critical for if, elif, else, loops, and function definitions. Incorrect indentation will lead to IndentationError or logical bugs.\nUse Cases in Structural Bioinformatics:\nData Quality Assessment:\n\nexperimental_method = \"X-RAY DIFFRACTION\" # From a PDB header\nresolution_angstroms = 1.9\n\nif \"X-RAY\" in experimental_method.upper(): # Check if \"X-RAY\" is part of the method string (case-insensitive search)\n    print(f\"Method is X-ray. Resolution: {resolution_angstroms} Å.\")\n    # Nested if statement: this inner decision only happens if the outer condition is true\n    if resolution_angstroms &lt; 1.5:\n        print(\"  This is a very high-resolution X-ray structure (excellent for details).\")\n    elif resolution_angstroms &lt; 2.5: # Only checked if resolution_angstroms was not &lt; 1.5\n        print(\"  This is a good-resolution X-ray structure (suitable for most analyses).\")\n    else: # Only executed if resolution_angstroms was not &lt; 1.5 AND not &lt; 2.5\n        print(\"  This X-ray structure has moderate to lower resolution (interpret with caution).\")\nelif \"NMR\" in experimental_method.upper(): # This block runs if the first 'if' (X-RAY) was False\n    print(\"Method is NMR. Analysis might involve an ensemble of models and different validation criteria.\")\nelif \"ELECTRON MICROSCOPY\" in experimental_method.upper() or \"EM\" in experimental_method.upper(): # Can check multiple terms\n    print(\"Method is Electron Microscopy. Resolution ranges widely, often higher for overall shape.\")\nelse: # This block runs if none of the above conditions were True\n    print(f\"Method is {experimental_method}. Specific analysis protocol may be needed for this experimental technique.\")\n\nMethod is X-ray. Resolution: 1.9 Å.\n  This is a good-resolution X-ray structure (suitable for most analyses).\n\n\nAtom/Residue Classification:\n\natom_name_to_classify = \"CB\" # C-beta atom, a sidechain atom\natom_category = \"\"\n\n# Check if the atom name is one of the standard backbone atoms\nif atom_name_to_classify in [\"N\", \"CA\", \"C\", \"O\"]:\n    atom_category = \"Backbone\"\n# If not a standard backbone atom, check if it starts with 'H' (for hydrogen atoms)\nelif atom_name_to_classify.startswith(\"H\"): # Example: HA, HB1, HG2 (all start with 'H')\n    atom_category = \"Hydrogen\"\n# If neither of the above, it's likely a sidechain heavy atom (e.g., CB, CG, SD, NE2 etc.)\nelse:\n    atom_category = \"Sidechain Heavy Atom\"\nprint(f\"Atom '{atom_name_to_classify}' is categorized as: {atom_category}\")\n\n# Example for a water molecule vs. protein residue\nresidue_type = \"HOH\"\nif residue_type == \"HOH\":\n    print(f\"{residue_type} is a water molecule.\")\nelif residue_type in [\"ALA\", \"GLY\", \"LEU\", \"LYS\"]: # Check against a list of common amino acids\n    print(f\"{residue_type} is a standard amino acid.\")\nelse:\n    print(f\"{residue_type} is a ligand or unknown residue.\")\n\nAtom 'CB' is categorized as: Sidechain Heavy Atom\nHOH is a water molecule.\n\n\nExercise: Given b_factor_value = 65.0. Write an if-elif-else statement that prints: * “Very stable” if b_factor_value is less than 20.0. * “Moderately stable” if b_factor_value is between 20.0 (inclusive) and 50.0 (exclusive). * “Flexible” if b_factor_value is 50.0or greater.\n\n\n2.4.2 Loops: Repeating Actions\nLoops are fundamental control flow statements that allow you to execute a block of code multiple times. This is incredibly powerful for automating repetitive tasks, processing large datasets, or performing iterative calculations that would be tedious or impossible to do manually.\n\nfor Loops: Purpose: A for loop is used to iterate over a sequence (like a string, list, or tuple) or any other iterable object. In each iteration, a temporary variable (often called the “loop variable”) takes on the value of the next item in the sequence, and the indented code block is executed.\n\nSyntax:\nfor item_variable in sequence_or_iterable: # Code to execute for each item statement1 statement2\n\nThe range() function: Often used with for loops to generate a sequence of numbers.\nrange(stop): Generates numbers from 0 up to (but not including) stop.\nrange(start, stop): Generates numbers from start up to (but not including) stop.\nrange(start, stop, step): Generates numbers from start up to (but not including) stop, incrementing by step each time.\n\nUse Cases in Structural Bioinformatics: * Iterating through atoms/residues: Processing each atom or residue parsed from a PDB file to perform calculations (e.g., distances, B-factor analysis) or extract specific information. * Sequence analysis: Processing each amino acid or nucleotide in a protein/DNA sequence to identify specific residues, calculate composition, or find motifs. * Batch processing: Looping through a list of PDB IDs to download, analyze, or generate reports for each one automatically. * Molecular Dynamics (MD) trajectory analysis: Iterating through frames of an MD trajectory to calculate properties over time.\n\nprotein_sequence_to_scan = \"ACEGIKMNPQSTVWYFL\" # All single letter codes except a few hydrophobic\nhydrophobic_amino_acids = \"AILMFWVP\" # Alanine, Isoleucine, Leucine, Methionine, Phenylalanine, Tryptophan, Valine, Proline\nhydrophobic_count = 0\n\nprint(f\"Scanning sequence: {protein_sequence_to_scan} for hydrophobic residues...\")\n# 'residue_code' will take on each character from the string 'protein_sequence_to_scan' one by one\nfor residue_code in protein_sequence_to_scan:\n    if residue_code in hydrophobic_amino_acids: # Check if the current residue code is in our set of hydrophobic amino acids\n        print(f\"  Found hydrophobic residue: {residue_code}\")\n        hydrophobic_count += 1 # Increment the counter\nprint(f\"Total hydrophobic residues found: {hydrophobic_count}\")\n\n# Using range() to simulate processing numbered models in an NMR structure\nnum_nmr_models = 10\nprint(\"\\nSimulating analysis of NMR models:\")\n# range(1, num_nmr_models + 1) generates numbers from 1 to 10 (inclusive)\nfor model_number in range(1, num_nmr_models + 1):\n    print(f\"  Processing NMR model {model_number}...\")\n    # (Imagine complex analysis code here for each model, e.g., calculating RMSD for each model)\n\nScanning sequence: ACEGIKMNPQSTVWYFL for hydrophobic residues...\n  Found hydrophobic residue: A\n  Found hydrophobic residue: I\n  Found hydrophobic residue: M\n  Found hydrophobic residue: P\n  Found hydrophobic residue: V\n  Found hydrophobic residue: W\n  Found hydrophobic residue: F\n  Found hydrophobic residue: L\nTotal hydrophobic residues found: 8\n\nSimulating analysis of NMR models:\n  Processing NMR model 1...\n  Processing NMR model 2...\n  Processing NMR model 3...\n  Processing NMR model 4...\n  Processing NMR model 5...\n  Processing NMR model 6...\n  Processing NMR model 7...\n  Processing NMR model 8...\n  Processing NMR model 9...\n  Processing NMR model 10...\n\n\nExercise: Given the peptide sequence peptide = \"GATPLES\". Iterate through each character (residue) in the sequence using a for loop. If a residue is 'P' (Proline), print “Proline found!”. Also, count how many 'S' (Serine) residues are present in the sequence and print the final count at the end of the loop.\n\nwhile Loops: Purpose: A while loop repeatedly executes a code block as long as a given condition remains True. The condition is checked before each iteration.\n\nSyntax: while condition: # Code to execute as long as condition is True statement1 statement2\nUse Cases in Structural Bioinformatics: * Iterative refinement: Iteratively refining a protein structure model until convergence criteria (e.g., RMSD change below a threshold) are met. * Simulation steps: Simulating steps in a molecular dynamics trajectory until a certain simulation time is reached. * File reading: Reading lines from a large PDB file until a specific section (e.g., ‘HETATM’ records) is found or the end of the file is reached. * User input validation: Repeatedly asking the user for input until valid input is provided.\n\n# Simulate iterative structure refinement until RMSD target is met or max iterations\ncurrent_rmsd_value = 5.0 # Initial RMSD in Angstroms\ntarget_rmsd_value = 0.5  # Desired RMSD value for convergence\niteration_count = 0\nmax_iterations = 100    # Safety limit to prevent infinite loops\n\nprint(\"\\nStarting structure refinement simulation:\")\n# The loop continues as long as RMSD is above target AND max iterations not reached\nwhile current_rmsd_value &gt; target_rmsd_value and iteration_count &lt; max_iterations:\n    print(f\"  Iteration {iteration_count + 1}: Current RMSD = {current_rmsd_value:.3f} Å\")\n    # In a real scenario, complex refinement calculations would occur here\n    current_rmsd_value -= 0.25 # Simulate RMSD improvement in each iteration\n    iteration_count += 1       # Increment the iteration counter\n\n# After the loop finishes, check why it stopped\nif current_rmsd_value &lt;= target_rmsd_value:\n    print(f\"Refinement converged after {iteration_count} iterations. Final RMSD: {current_rmsd_value:.3f} Å.\")\nelse:\n    print(f\"Max iterations ({max_iterations}) reached. Refinement stopped. Final RMSD: {current_rmsd_value:.3f} Å.\")\n\n\nStarting structure refinement simulation:\n  Iteration 1: Current RMSD = 5.000 Å\n  Iteration 2: Current RMSD = 4.750 Å\n  Iteration 3: Current RMSD = 4.500 Å\n  Iteration 4: Current RMSD = 4.250 Å\n  Iteration 5: Current RMSD = 4.000 Å\n  Iteration 6: Current RMSD = 3.750 Å\n  Iteration 7: Current RMSD = 3.500 Å\n  Iteration 8: Current RMSD = 3.250 Å\n  Iteration 9: Current RMSD = 3.000 Å\n  Iteration 10: Current RMSD = 2.750 Å\n  Iteration 11: Current RMSD = 2.500 Å\n  Iteration 12: Current RMSD = 2.250 Å\n  Iteration 13: Current RMSD = 2.000 Å\n  Iteration 14: Current RMSD = 1.750 Å\n  Iteration 15: Current RMSD = 1.500 Å\n  Iteration 16: Current RMSD = 1.250 Å\n  Iteration 17: Current RMSD = 1.000 Å\n  Iteration 18: Current RMSD = 0.750 Å\nRefinement converged after 18 iterations. Final RMSD: 0.500 Å.\n\n\nCaution: When using while loops, it is absolutely critical to ensure that the condition will eventually become False. If the condition never evaluates to False, your program will enter an infinite loop, running forever and potentially freezing your environment. Always include a mechanism (like an incrementing counter with a max_iterations limit, or a condition that will definitely change state) to guarantee that the loop will terminate.\n\nbreak and continue Statements (within loops): These statements provide more fine-grained control over loop execution, allowing you to alter the normal flow within a loop.\n\nbreak:\nPurpose: Immediately terminates the innermost loop it is in. Execution then continues with the first statement after the loop (if any).\nUse Cases: Stop processing atoms in a PDB file if a critical formatting error is found. If you are searching for the first structure meeting certain criteria in a list of PDB IDs, break after finding it to save computation time and move on to the next part of your script.\ncontinue:\nPurpose: Skips the rest of the current iteration of the loop and immediately proceeds to the next iteration (checks the loop condition again). The loop itself continues to run, but the current item is effectively ignored for the remaining part of the current pass.\nUse Cases: When iterating through atoms, use continue to skip hydrogen atoms if they are not needed for the current analysis (e.g., only interested in heavy atoms). If a residue in a PDB file has incomplete coordinate data, continue to the next residue to avoid errors, rather than stopping the whole process.\n\n\n\npdb_ids_to_process = [\"1AKE\", \"2HHB\", \"MISSING_FILE\", \"1CRN\", \"6M0J\"]\nprint(\"\\nProcessing PDB IDs, stopping if a 'MISSING_FILE' is encountered:\")\nfor pdb_id in pdb_ids_to_process:\n    if pdb_id == \"MISSING_FILE\":\n        print(f\"  Error: PDB ID '{pdb_id}' indicates a problem. Halting process.\")\n        break # Exit the 'for' loop entirely\n    print(f\"  Successfully processed (simulated) PDB ID: {pdb_id}\")\nprint(\"Loop finished (due to break or exhaustion of list).\")\n\n\nprint(\"\\nCalculating average B-factor for non-hydrogen atoms (simplified):\")\n# Assume atom_data is a list of tuples: (atom_name, b_factor)\natom_data_from_pdb_residue = [(\"N\", 22.5), (\"CA\", 20.1), (\"C\", 21.0), (\"O\", 23.5),\n                              (\"CB\", 25.0), (\"H\", 18.0), (\"HA\", 19.5), (\"HB1\", 20.0)] # H, HA, HB1 are hydrogens\ntotal_b_factor_heavy_atoms = 0\ncount_heavy_atoms = 0\n\nfor atom_name, b_factor_val in atom_data_from_pdb_residue:\n    if atom_name.startswith(\"H\"): # If it's a hydrogen atom (names usually start with H)\n        print(f\"  Skipping hydrogen atom: {atom_name}\")\n        continue # Skip the rest of this iteration and go directly to the next atom in the list\n\n    print(f\"  Including heavy atom: {atom_name}, B-factor: {b_factor_val}\")\n    total_b_factor_heavy_atoms += b_factor_val\n    count_heavy_atoms += 1\n\nif count_heavy_atoms &gt; 0:\n    average_b_heavy = total_b_factor_heavy_atoms / count_heavy_atoms\n    print(f\"Average B-factor for heavy atoms: {average_b_heavy:.2f}\")\nelse:\n    print(\"No heavy atoms found to calculate average B-factor.\")\n\n\nProcessing PDB IDs, stopping if a 'MISSING_FILE' is encountered:\n  Successfully processed (simulated) PDB ID: 1AKE\n  Successfully processed (simulated) PDB ID: 2HHB\n  Error: PDB ID 'MISSING_FILE' indicates a problem. Halting process.\nLoop finished (due to break or exhaustion of list).\n\nCalculating average B-factor for non-hydrogen atoms (simplified):\n  Including heavy atom: N, B-factor: 22.5\n  Including heavy atom: CA, B-factor: 20.1\n  Including heavy atom: C, B-factor: 21.0\n  Including heavy atom: O, B-factor: 23.5\n  Including heavy atom: CB, B-factor: 25.0\n  Skipping hydrogen atom: H\n  Skipping hydrogen atom: HA\n  Skipping hydrogen atom: HB1\nAverage B-factor for heavy atoms: 22.42\n\n\nExercise Idea: You have a list of residue names: residues = [“ALA”, “HIS”, “UNK”, “LEU”, “GLY”]. Loop through them. If a residue is “UNK” (unknown), print “Unknown residue found, skipping!” and use continue. Otherwise, print “Processing residue: [name]”.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Fundamentals</span>"
    ]
  }
]