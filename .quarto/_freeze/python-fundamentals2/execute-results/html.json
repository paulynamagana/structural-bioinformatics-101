{
  "hash": "8f7fb7b455a55c0453c446d2c6b14014",
  "result": {
    "engine": "jupyter",
    "markdown": "## Operators: The Tools for Data Manipulation\n\nOperators are special symbols or keywords that perform operations on\nvariables and values (called operands). Understanding operators is\ncrucial for performing calculations, making comparisons, and combining\nconditions in your code.\n\n**Arithmetic Operators**:\n\nUsed to perform mathematical calculations.\n\nOperators: \\* + (Addition) \\* - (Subtraction) \\* \\* (Multiplication) \\*\n/ (True Division): Performs standard division, always returning a float\n(even if the result is a whole number).\n\n-   // (Floor Division): Performs division and returns the integer part\n    of the quotient (rounds down to the nearest whole number).\n\n-   \\% (Modulo): Returns the remainder of a division.\n\n-   \\*\\* (Exponentiation): Raises the first operand to the power of the\n    second.\n\nUse Cases in Structural Bioinformatics:\n\n-   Calculating distances between atoms (e.g., Euclidean distance:\n-   Averaging B-factors or other numerical properties.\n-   Scaling coordinates.\n-   Calculating molecular weights (summing up atomic weights).\n\n::: {#2765aa79 .cell execution_count=1}\n``` {.python .cell-code}\n# Simplified distance calculation in 1D for now\natom1_x = 10.0\natom2_x = 15.5\ndelta_x = atom2_x - atom1_x # Difference in X-coordinate: 5.5\ndistance_sq_x = delta_x ** 2 # Square of the difference: 5.5 * 5.5 = 30.25\nprint(f\"Difference in X: {delta_x}, Squared difference: {distance_sq_x}\")\n\n# Average B-factor of two atoms\nb_factor1 = 20.5\nb_factor2 = 30.1\naverage_b_factor = (b_factor1 + b_factor2) / 2 # Division results in float: 25.3\nprint(f\"Average B-factor: {average_b_factor}\")\n\nsequence_length = 101 # Example: number of residues\nresidues_per_turn_helix = 3.6 # Approximate number of residues per turn in an alpha-helix\napprox_turns = sequence_length / residues_per_turn_helix # True division: 101 / 3.6 = 28.055...\nfull_turns = sequence_length // residues_per_turn_helix # Floor division: 101 // 3.6 = 28.0 (type is float but value is integer part)\n# Note: If both operands are integers, // returns an integer. If either is float, it returns a float.\nprint(f\"Approximate turns in helix: {approx_turns:.2f}, Full turns: {full_turns}\")\n\nremainder_check = 10 % 3 # Modulo: 10 divided by 3 is 3 with a remainder of 1\nprint(f\"Remainder of 10 / 3: {remainder_check}\") # Output: 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDifference in X: 5.5, Squared difference: 30.25\nAverage B-factor: 25.3\nApproximate turns in helix: 28.06, Full turns: 28.0\nRemainder of 10 / 3: 1\n```\n:::\n:::\n\n\nExercise: Given x1 = 5.0, y1 = 10.0 and x2 = 8.0, y2 = 14.0. Calculate\nthe squared distance in 2D: $$(x2−x1)^2+(y2−y1)^2$$ Store the result in\na variable sq_dist_2d and print it.\n\n**Comparison Operators**:\n\nWhat they are: Used to compare two values. They always return a Boolean\nvalue (True or False).\n\nOperators:\n\n-   `==` (Equal to): Returns True if two operands have the same value.\n-   `!=` (Not equal to): Returns True if two operands have different\n    values.\n-   `>` (Greater than)\n-   `<` (Less than)\n-   `>=` (Greater than or equal to)\n-   `<=` (Less than or equal to)\n\nUse Cases in Structural Bioinformatics:\n\n-   Comparing resolution values: `resolution1 < resolution2`.\n-   Checking if a B-factor exceeds a threshold: `b_factor > 70.0`.\n-   Comparing atom names: `atom_name == 'CA'`.\n-   Checking if a residue number is within a specific range:\n    `residue_number >= 10 and residue_number <= 20`.\n\n::: {#0e8b3234 .cell execution_count=2}\n``` {.python .cell-code}\nmy_protein_resolution = 1.8 # Angstroms\nacceptable_resolution_max = 2.5\nis_good_resolution = my_protein_resolution <= acceptable_resolution_max # 1.8 is less than or equal to 2.5, so True\nprint(f\"Is resolution {my_protein_resolution}Å acceptable (<= {acceptable_resolution_max}Å)? {is_good_resolution}\")\n\natom_type = \"C\"\nis_carbon_atom = atom_type == \"C\" # Is \"C\" equal to \"C\"? True\nprint(f\"Is atom_type '{atom_type}' a Carbon? {is_carbon_atom}\")\n\n# Check if a chain ID is not 'X' (often used for unknown chains)\nchain_id = \"A\"\nis_not_unknown_chain = chain_id != \"X\" # \"A\" is not equal to \"X\", so True\nprint(f\"Is chain '{chain_id}' not an unknown chain? {is_not_unknown_chain}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIs resolution 1.8Å acceptable (<= 2.5Å)? True\nIs atom_type 'C' a Carbon? True\nIs chain 'A' not an unknown chain? True\n```\n:::\n:::\n\n\nExercise: A typical hydrogen bond length is between 2.7 and 3.3\nAngstroms. Given measured_hbond_length = 2.9, write a comparison to\ncheck if it's less than or equal to 3.3. Print the result.\n\n**Logical Operators** What they are: Used to combine multiple Boolean\nexpressions. They also return a Boolean value (True or False).\n\nOperators:\n\n-   `and`: Returns True if both operands are True.\n-   `or`: Returns True if at least one of the operands is True.\n-   `not`: Reverses the logical state of its operand (if `True` becomes\n    `False`, if `False` becomes `True`).\n\nUse Cases in Structural Bioinformatics:\n\n-   Checking if a residue is part of an alpha-helix `AND` is solvent\n    exposed: `is_helix and is_exposed`.\n-   Checking if an atom is a backbone atom (C-alpha OR N OR C OR O):\n    `(atom_name == 'CA') or (atom_name == 'N') or (atom_name == 'C') or (atom_name == 'O')`.\n-   Checking if a structure is not an NMR structure: not\n    `(experimental_method == 'NMR')`.\n\n::: {#7185271c .cell execution_count=3}\n``` {.python .cell-code}\nis_hydrophobic_residue = True\nis_surface_exposed = False\n# Is it a surface-exposed hydrophobic residue? Both conditions must be True.\nis_hydrophobic_and_surface = is_hydrophobic_residue and is_surface_exposed # True and False -> False\nprint(f\"Is the residue hydrophobic AND surface exposed? {is_hydrophobic_and_surface}\")\n\natom_name_check = \"CB\" # C-beta\n# Is it a main chain atom? (N, CA, C, or O)\nis_main_chain_atom = (atom_name_check == \"N\" or atom_name_check == \"CA\" or atom_name_check == \"C\" or atom_name_check == \"O\")\n# \"CB\" == \"N\" (False) OR \"CB\" == \"CA\" (False) OR \"CB\" == \"C\" (False) OR \"CB\" == \"O\" (False)\n# False or False or False or False -> False\nprint(f\"Is atom '{atom_name_check}' a main chain atom? {is_main_chain_atom}\")\nprint(f\"Is atom '{atom_name_check}' NOT a main chain atom? {not is_main_chain_atom}\") # not False -> True\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIs the residue hydrophobic AND surface exposed? False\nIs atom 'CB' a main chain atom? False\nIs atom 'CB' NOT a main chain atom? True\n```\n:::\n:::\n\n\n**Assignment Operators** What they are: Used to assign values to\nvariables.\n\nOperators:\n\n-   `=` (Assignment): The basic assignment operator.\n-   `+=` (Add and assign): `x += y`is equivalent to `x = x + y`.\n-   `-=` (Subtract and assign): `x -= y` is equivalent to `x = x - y`.\n-   `*=` (Multiply and assign): `x *= y` is equivalent to `x = x * y`.\n-   `/=` (Divide and assign): `x /= y`is equivalent to `x = x / y`.\n-   And others for floor division (`//=`), modulo (`%=`), exponentiation\n    (`**=`).\n\nUse Cases:\n\n-   Incrementing counters: `atom_count += 1`.\n-   Accumulating sums: `total_energy += current_interaction_energy`.\n-   Updating properties based on calculations.\n\n::: {#74290cfe .cell execution_count=4}\n``` {.python .cell-code}\nnum_hydrogen_bonds = 0\nprint(f\"Initial hydrogen bonds: {num_hydrogen_bonds}\")\n# ... some code finds a hydrogen bond ...\nnum_hydrogen_bonds += 1 # Increment by 1. Equivalent to: num_hydrogen_bonds = num_hydrogen_bonds + 1\nprint(f\"Number of hydrogen bonds found: {num_hydrogen_bonds}\")\n\nprotein_weight = 1000.0 # Initial hypothetical weight\n# During refinement, suppose a modification adds 50.0 Daltons\nprotein_weight += 50.0\nprint(f\"Updated protein weight: {protein_weight} Da\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInitial hydrogen bonds: 0\nNumber of hydrogen bonds found: 1\nUpdated protein weight: 1050.0 Da\n```\n:::\n:::\n\n\n**Membership Operators**\n\nWhat they are: Used to test if a sequence (like a string, list, or\ntuple) contains a specific value.\n\nOperators: \\* `in`: Returns True if the value is found in the sequence.\n\\* `not` in: Returns True if the value is not found in the sequence.\n\nUse Cases in Structural Bioinformatics: \\* Checking if a specific amino\nacid is in a protein sequence: `'LYS' in protein_sequence`. \\* Checking\nif a ligand ID (e.g., `'HOH'` for water) is in a list of ligands found\nin a PDB file. \\* Checking if an atom name is in a list of known\nbackbone atoms: `atom_name in ['N', 'CA', 'C', 'O']`.\n\n::: {#f77f80b0 .cell execution_count=5}\n``` {.python .cell-code}\nprotein_sequence_example = \"MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGG\"\nis_tryptophan_present = \"W\" in protein_sequence_example # W is Tryptophan: True\nprint(f\"Is Tryptophan ('W') in the sequence? {is_tryptophan_present}\")\n\nactive_site_residue_numbers = [45, 48, 97, 101, 152] # Example list of residue numbers\ncurrent_residue_num = 101\nis_in_active_site = current_residue_num in active_site_residue_numbers # 101 is in the list: True\nprint(f\"Is residue {current_residue_num} in the active site list? {is_in_active_site}\")\n\n# Check for a non-existent residue\nnon_existent_residue_num = 200\nis_not_in_active_site = non_existent_residue_num not in active_site_residue_numbers # 200 is not in the list: True\nprint(f\"Is residue {non_existent_residue_num} NOT in the active site list? {is_not_in_active_site}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIs Tryptophan ('W') in the sequence? False\nIs residue 101 in the active site list? True\nIs residue 200 NOT in the active site list? True\n```\n:::\n:::\n\n\nExercise: Given a list of common metal ions found in proteins:\nmetal_ions = \\[\"ZN\", \"MG\", \"FE\", \"CA\"\\]. Check if \"CU\" (Copper) is in\nthis list. Then check if \"MG\" (Magnesium) is in this list. Print both\nboolean results.\n\nIdentity Operators: What they are: Used to compare if two variables\nrefer to the exact same object in memory, not just if they have the same\nvalue.\n\nOperators:\n\n-   `is`: Returns True if both variables point to the same object.\n-   `is not`: Returns True if both variables do not point to the same\n    object.\n-   **Note**: For comparing values (e.g., if two numbers or strings are\n    equal), you almost always want to use == (equality operator). The is\n    operator is more subtle and less frequently used for basic value\n    checks by beginners. It becomes relevant when you are dealing with\n    object references, especially for mutable objects like lists.\n\n::: {#e5d76f9c .cell execution_count=6}\n``` {.python .cell-code}\nlist_a = [10, 20, 30]\nlist_b = [10, 20, 30] # list_b has the same values as list_a, but it's a *different object* in memory\nlist_c = list_a      # list_c is assigned to *refer to the same object* as list_a\n\nprint(f\"list_a == list_b (value equality): {list_a == list_b}\") # True (values are the same)\nprint(f\"list_a is list_b (identity): {list_a is list_b}\")     # False (they are distinct objects)\nprint(f\"list_a is list_c (identity): {list_a is list_c}\")     # True (they refer to the same object)\n\n# Let's see the effect of modifying list_c\nlist_c.append(40)\nprint(f\"List A after modifying C: {list_a}\") # Output: [10, 20, 30, 40] - list_a was also changed!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlist_a == list_b (value equality): True\nlist_a is list_b (identity): False\nlist_a is list_c (identity): True\nList A after modifying C: [10, 20, 30, 40]\n```\n:::\n:::\n\n\n## Essential Built-in Functions\n\nPython has many built-in functions that are always available for use\nwithout needing to import them from a module. These functions perform\ncommon tasks, making your coding more efficient. `print()`:\n\nWhat it does: Displays output (text, variable values) to the console.\nThis is your primary tool for seeing what your code is doing and for\ndebugging.\n\nHow to use: You can pass multiple arguments separated by commas, and\nprint() will separate them with a space by default. f-strings (formatted\nstring literals): The most modern and recommended way to embed variable\nvalues directly into strings for printing. They start with an f before\nthe opening quote, and variables are enclosed in curly braces {} within\nthe string. You can also apply formatting (e.g., :.2f for two decimal\nplaces for a float). Use Cases: Printing PDB ID, number of atoms,\nspecific coordinates, results of calculations (e.g., print(f'Distance\nbetween atom {atom_serial_1} and atom {atom_serial_2}: {dist_value:.2f}\nAngstroms')). Providing progress updates during long analyses.\n\n::: {#5528fbee .cell execution_count=7}\n``` {.python .cell-code}\npdb_code_to_print = \"1TIM\"\nchain_id_to_print = \"A\"\nnum_residues_to_print = 248\n\n# Basic printing with commas\nprint(\"Analyzing structure\", pdb_code_to_print, \"chain\", chain_id_to_print)\n\n# Using an f-string for clear, embedded values and formatting\nprint(f\"Analyzing structure {pdb_code_to_print}, chain {chain_id_to_print}, which has {num_residues_to_print} residues.\")\n\n# Formatting a float in an f-string\ncalculated_rmsd = 1.23456\nprint(f\"The RMSD is {calculated_rmsd:.3f} Å.\") # Prints 1.235 (rounded to 3 decimal places)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnalyzing structure 1TIM chain A\nAnalyzing structure 1TIM, chain A, which has 248 residues.\nThe RMSD is 1.235 Å.\n```\n:::\n:::\n\n\n",
    "supporting": [
      "python-fundamentals2_files"
    ],
    "filters": [],
    "includes": {}
  }
}