{
  "hash": "2cd5b9154c8135d79027bf989cffb769",
  "result": {
    "engine": "jupyter",
    "markdown": "## Variables and Data Types\n\nIn programming, a variable is like a named container or a labeled box in your computer's memory where you can store data. When you want to use that data later, you just refer to the variable's name.\n\nPython is a dynamically typed language. This means you don't need to explicitly tell Python what type of data a variable will hold (e.g., integer, text, decimal number) when you create it. Python automatically infers the type based on the value you assign. This makes Python very flexible and quicker to write for beginners, but it also means you need to be mindful of the data types you're working with during operations.\n\n**Variable Naming Rules (PEP 8 Style)**: To make your code readable and consistent (especially important when working with others or revisiting your own code later), follow these common conventions:\n\n-   **Lowercase with underscores (snake_case)**: This is the standard for variable and function names. Examples: pdb_id, atom_count, active_site_residues.\n\n-   **Start with a letter or underscore**: Variable names cannot begin with a number.\n\n    -   Valid: \\_temp_value, residue_10, chain_A.\n    -   Invalid: 10_residues, 2nd_atom\n\n-   **Case-sensitive**: Python distinguishes between uppercase and lowercase letters. atom_name is a completely different variable from Atom_Name.\n\n-   **Avoid Python keywords**: Do not use words that Python reserves for its own syntax (e.g., if, for, list, def, return, True, False, None). Using them will cause a SyntaxError.\n\n-   **Be descriptive**: Choose names that clearly indicate the purpose or content of the variable. This makes your code much easier to understand.Good: active_site_residues, rmsd_value_angstroms, protein_sequenceBad: asr, x, p_seq\n\n**Common Data Types in Python for Structural Biology**\n\nPython comes with several built-in data types that are fundamental for storing and manipulating information. Here are the most common ones you'll encounter, with a focus on their applications in structural bioinformatics:\n\n-   **Integers (`int`)**: What they are: Whole numbers (positive, negative, or zero) without any fractional part.\n\n-   **Use Cases in Structural Bioinformatics**:\n\n    -   Counting discrete entities: number_of_atoms = 4582, chain_count = 2.\n    -   Identifiers: residue_number = 101, atom_serial_number = 1560.\n    -   Simulation steps: simulation_step = 50000.\n\n::: {#2387b89f .cell execution_count=1}\n``` {.python .cell-code}\nnumber_of_amino_acids = 287\natom_serial_number = 1560\n\nprint(f\"Number of amino acids: {number_of_amino_acids}\")\nprint(f\"Atom serial number: {atom_serial_number}\")\n\n# The type() function tells you what data type a variable holds\nprint(f\"Type of atom_serial_number: {type(atom_serial_number)}\") # Output: <class 'int'>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of amino acids: 287\nAtom serial number: 1560\nType of atom_serial_number: <class 'int'>\n```\n:::\n:::\n\n\nExercise: Define a variable `total_atoms_in_myoglobin` and assign it an approximate number of atoms (e.g., 1260). Print the variable and its type.\n\n-   **Floating-Point Numbers (`float`)**:\n\nWhat they are: Numbers that have a decimal point or are expressed in scientific notation. They are used to represent real numbers, often for measurements that are not whole numbers.\n\n-   Use Cases in Structural Bioinformatics:\n\n-   Atomic coordinates: `x_coord = 12.345`, `y_coord = -4.567`, `z_coord = 18.901`.\n\n-   Measurements: RMSD values (`rmsd_value = 1.5`), B-factors `(b_factor = 45.67`), bond lengths (`bond_length_angstroms = 1.54`), solvent accessible surface area (SASA), resolution of crystal structures.\n\n::: {#942b7cf6 .cell execution_count=2}\n``` {.python .cell-code}\n# Atomic coordinates for a C-alpha atom\nca_x_coord = 10.253\nca_y_coord = -5.781\nca_z_coord = 22.019\nprint(f\"C-alpha coordinates: X={ca_x_coord}, Y={ca_y_coord}, Z={ca_z_coord}\")\n\nrmsd_to_native = 0.85 # Angstroms (Å is the symbol for Angstrom)\nprint(f\"RMSD to native structure: {rmsd_to_native} Å\")\nprint(f\"Type of rmsd_to_native: {type(rmsd_to_native)}\") # Output: <class 'float'>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nC-alpha coordinates: X=10.253, Y=-5.781, Z=22.019\nRMSD to native structure: 0.85 Å\nType of rmsd_to_native: <class 'float'>\n```\n:::\n:::\n\n\nExercise: Define three float variables: coord_x = 10.123, coord_y = -4.567, coord_z = 18.901. Print these coordinates in a formatted string, perhaps like \"Coordinates: (X: 10.123, Y: -4.567, Z: 18.901)\".\n\n-   **Strings (`str`)**:\n\nWhat they are: Sequences of characters (text). Strings are immutable, meaning once created, their individual characters cannot be changed. Any operation that seems to modify a string actually creates a new string.\n\nHow to define strings:\n\n-   Single quotes ('...') or Double quotes (\"...\"): Use these for single-line strings. It's largely a matter of personal preference or team convention, but choose one and stick to it for consistency.\n\n    -   If your string contains an apostrophe, use double quotes to avoid issues (e.g., \"It's a protein\").\n\n    -   If your string contains double quotes, use single quotes (e.g., 'The \"alpha\" carbon').\n\n-   Triple quotes (\"\"\"...\"\"\" or '''...'''): Use triple single or double quotes for multi-line strings. This is extremely useful for storing blocks of text, such as descriptions, help messages, or raw data snippets that span multiple lines, like a portion of a PDB file header or a long protein sequence.\n\n**Use Cases in Structural Bioinformatics**:\n\n-   PDB IDs: `pdb_id = '1AKE'`, `protein_data_bank_id = \"2HHB\"`.\n\n-   Atom names: `atom_name = 'CA'`, `element_symbol = \"C\"`.\n\n-   Residue names: `residue_name = 'ALA'`, `three_letter_code = \"GLY\"`.\n\n-   Chain identifiers: `chain_id = 'A'`.\n\n-   Biological sequences: `protein_sequence = \"MVLSEGEWQLVLHVWAKVEAD\"`, `dna_sequence = \"ATGCGTAGCATG\"`.\n\n-   File paths: `pdb_file_path = \"data/1crn.pdb\"`.\n\n-   Lines from data files: `atom_record_line_pdb = \"ATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\"`.\n\n::: {#483aca48 .cell execution_count=3}\n``` {.python .cell-code}\nprotein_data_bank_id = \"2HHB\" # Hemoglobin\namino_acid_sequence_snippet = \"VLSPADKTNVKAAWGKVGAHAGEYGAEALE\"\n\n# A multi-line string for a simplified PDB ATOM record example\natom_record_line_pdb = \"\"\"\nATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\nATOM      2  CA  MET A   1      25.500  23.800  23.100  1.00 12.00           C\n\"\"\"\nprint(f\"Analyzing PDB ID: {protein_data_bank_id}\")\nprint(f\"Amino acid sequence snippet: {amino_acid_sequence_snippet}\")\nprint(f\"Example PDB ATOM line (multi-line): {atom_record_line_pdb}\")\nprint(f\"Type of protein_data_bank_id: {type(protein_data_bank_id)}\") # Output: <class 'str'>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnalyzing PDB ID: 2HHB\nAmino acid sequence snippet: VLSPADKTNVKAAWGKVGAHAGEYGAEALE\nExample PDB ATOM line (multi-line): \nATOM      1  N   MET A   1      26.654  24.145  24.409  1.00 10.00           N\nATOM      2  CA  MET A   1      25.500  23.800  23.100  1.00 12.00           C\n\nType of protein_data_bank_id: <class 'str'>\n```\n:::\n:::\n\n\nExercise: Create a string variable `target_pdb_code` and assign it `\"1CBS\"`. Create another string variable `ligand_name` and assign it `\"STI\"` (a substrate analog for 1CBS). Print both variables in a sentence, e.g., \"The target PDB is \\[code\\], and its ligand is \\[name\\].\"\n\n-   **Booleans (`bool`)**:\n\nWhat they are: Truth values. A boolean variable can only hold one of two possible values: True or False. These are special keywords in Python (notice the capital first letter). Booleans are the foundation of decision-making in your code.\n\nUse Cases in Structural Bioinformatics:\n\n-   Flags for presence/absence: `is_ligand_present = True`, `has_hydrogen_atoms_in_pdb = False`.\n\n-   Results of comparisons: `resolution_ok = (pdb_resolution < 2.0)`, `is_distance_significant = (2.8 < 3.5)`.\n\n-   Categorization: `is_alpha_helix = True`, `is_clash_detected = False`.\n\n::: {#f308200d .cell execution_count=4}\n``` {.python .cell-code}\nis_structure_solved_by_xray = True\nhas_hydrogen_atoms_in_pdb = False # Often true for NMR, sometimes for high-res X-ray, but usually False for older X-ray PDBs\nis_distance_significant = (2.8 < 3.5) # This is a comparison, which directly evaluates to True or False\nprint(f\"Structure solved by X-ray? {is_structure_solved_by_xray}\")\nprint(f\"Hydrogen atoms present? {has_hydrogen_atoms_in_pdb}\")\nprint(f\"Is the distance significant for an H-bond (2.8 < 3.5)? {is_distance_significant}\")\nprint(f\"Type of is_distance_significant: {type(is_distance_significant)}\") # Output: <class 'bool'>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStructure solved by X-ray? True\nHydrogen atoms present? False\nIs the distance significant for an H-bond (2.8 < 3.5)? True\nType of is_distance_significant: <class 'bool'>\n```\n:::\n:::\n\n\nExercise: Imagine you've calculated the B-factor of an atom as `b_factor_value = 55.2`. Create a boolean variable `is_atom_flexible` that is `True` if `b_factor_value` is greater than 50.0, and False otherwise. Print the value of `is_atom_flexible.`\n\n-   **Type Conversion (Casting)**:\n\nSometimes, you need to convert data from one type to another. This process is called \"type conversion\" or \"casting.\" Python provides built-in functions for this: `int()`, `float()`, `str()`, `bool()`.\n\nContext in Structural Bioinformatics: A common scenario is when you read data from a file (like a PDB file). Although numbers (coordinates, B-factors, occupancy) are stored as text (strings) in the file, you'll need to convert them to `float` or `int` to perform numerical calculations.\n\n::: {#cd14e406 .cell execution_count=5}\n``` {.python .cell-code}\ncoordinate_str = \"12.345\" # This value is read as a string from a PDB file line\ncoordinate_float = float(coordinate_str) # Convert the string to a floating-point number\nprint(f\"Coordinate string '{coordinate_str}' as float: {coordinate_float}\")\nprint(f\"Type of coordinate_float: {type(coordinate_float)}\") # Output: <class 'float'>\n\natom_count_str = \"5000\"\natom_count_int = int(atom_count_str) # Convert the string to an integer\nprint(f\"Atom count '{atom_count_str}' as int: {atom_count_int}\")\nprint(atom_count_int * 2) # Now arithmetic operations are possible: 10000\n\n# Careful with float to int conversion: it truncates (chops off the decimal part), it does NOT round.\noccupancy_str = \"0.75\"\noccupancy_float = float(occupancy_str)\noccupancy_int_truncated = int(occupancy_float) # Becomes 0 (truncates 0.75 to 0)\nprint(f\"Occupancy '{occupancy_str}' as float: {occupancy_float}, as int (truncated): {occupancy_int_truncated}\")\n\n# Converting to boolean:\n# Most non-empty strings, non-zero numbers, non-empty lists/tuples/dictionaries evaluate to True\n# Empty strings, 0, None, empty lists/tuples/dictionaries evaluate to False\nis_present_str = \"True\"\nis_present_bool = bool(is_present_str) # This will be True because the string \"True\" is not empty\nprint(f\"'{is_present_str}' as boolean: {is_present_bool}\")\n\nempty_sequence_str = \"\"\nis_empty_bool = bool(empty_sequence_str) # This will be False\nprint(f\"'{empty_sequence_str}' as boolean: {is_empty_bool}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate string '12.345' as float: 12.345\nType of coordinate_float: <class 'float'>\nAtom count '5000' as int: 5000\n10000\nOccupancy '0.75' as float: 0.75, as int (truncated): 0\n'True' as boolean: True\n'' as boolean: False\n```\n:::\n:::\n\n\n",
    "supporting": [
      "python-fundamentals-1_files"
    ],
    "filters": [],
    "includes": {}
  }
}